<!-- <!DOCTYPE html> -->
<link rel="stylesheet" type ="text/css"  href="board.css">
<div class = "container"></div>
<div class = "winner">
    <head>

    </head>
</div>
<!-- <div class = "blackAIButton"> -->
<button onclick="colorAI('white')" class = whiteAIButton>Move White With AI</button>

<button onclick="colorAI('black')" class = blackAIButton>Move Black With AI</button>

    <!-- <button onclick="testingBoardAs2DArray()" class = testingBoardAs2DArray>test</button>
    <button onclick="testGlobalNessOfSquareMatrix()" class = testingGlobal>test global</button> -->
    <!-- <button class="button">Button</button> -->
<!-- </div> -->

<!-- <button onclick="firstFunction()" class = firstFunction>first function</button> -->
<!-- <button onclick="testingColor('white')" class = testingColor>testingWhite</button> -->
<!-- <button onclick="testingColor('black')" class = testingColor>testingBlack</button> -->

<div class="currentPlayer"> 
    <span class = "player"></span>
<div class="board"></div>
<div class="restart">
    <button class="playAgain">play again</button>
</div>


<!-- <div class = "moveBlackWithAI">
    <button class = "blackAIButton">Move Black</button>
</div> -->








<!-- <div class = "pieces">
    <div class = "white-pawn"></div>
    <div class = "white-bishop"></div>
    <div class = "white-rook"></div>
    <div class = "white-knight"></div>
    <div class = "white-queen"></div>
    <div class = "white-king"></div>
    <div class = "black-pawn"></div>
    <div class = "black-bishop"></div>
    <div class = "black-rook"></div>
    <div class = "black-knight"></div>
    <div class = "black-queen"></div>
    <div class = "black-king"></div>
</div> -->

<h6 class = "h6"  id = "h6">
    Check out the code for this project on <a href="https://github.com/AnderSwartz/chessAI" target = "_blank">my Github</a>
</h6>
</div>



<script>

document.addEventListener("keypress", function onPress(event) {
    if (event.keyCode == 13) {
        colorAI(currentPlayer.slice(0,5).toLowerCase())
    }
});




async function firstFunction(){
    console.log("starting firstFunction")
    await secondFunction()
    console.log("ending firstFunction")
}

function secondFunction(){
    return new Promise((resolve,reject)=>{
    //here our function should be implemented 
    setTimeout(()=>{
        console.log("Hello from inside the testAsync function");
        resolve();
    ;} ,
    );
});
}

function testingColor(color){
    // alert(color)
    console.log(color+"-king")
    document.getElementsByClassName(color+"-king")[0].classList.add("check")

    
    window[color+"Pawn"](squares[8]);
    LastSelectedPiece[color+"LastSelectedPiece"] = color+"LastSelectedPiece"
    console.log(whiteLastSelectedPiece)
    console.log(blackLastSelectedPiece)

    
}

var squaresMatrix = new Array
var previouslyClickedSquare
whiteWon = false
blackWon = false
let board=document.querySelector(".board") 
let player=document.querySelector(".player") 
let playAgain=document.querySelector(".playAgain") 
let restart=document.querySelector(".restart") 
let moveBlackWithAI = document.querySelector("moveBlackWithAI")
let blackAIButton = document.querySelector("blackAIButton")
console.log(moveBlackWithAI)
let box=0
let currentPlayer="White's turn"
var blackLastSelectedPiece = ""
var blackLastSelectedLocation = ""
var whiteLastSelectedPiece = ""
var whiteLastSelectedLocation = ""

var squareswhiteCanAttack
var squaresblackCanAttack

var blackCastleableQS = true
var blackCastleableKS = true

var whiteCastleableQS= true
var whiteCastleableKS= true

var whiteWeight = 1
var blackWeight = -1
var piecesAttackingKing = []

var squares
var x
var y
var blackPieces = ["black-pawn","black-bishop","black-knight","black-rook","black-queen","black-king"]
var whitePieces = ["white-pawn","white-bishop","white-knight","white-rook","white-queen","white-king"]
var allPieces = ["black-pawn","black-bishop","black-knight","black-rook","black-queen","black-king",
"white-pawn","white-bishop","white-knight","white-rook","white-queen","white-king"]
const vars = {
    whiteLastSelectedPiece,
    blackLastSelectedPiece,
    whiteLastSelectedLocation,
    blackLastSelectedLocation,
    whitePieces,
    blackPieces,
    whiteCastleableQS,
    whiteCastleableKS,
    blackCastleableQS,
    blackCastleableKS,
    whitePieces,
    blackPieces,
    squareswhiteCanAttack,
    squaresblackCanAttack,
    whiteWeight,
    blackWeight
}
document.addEventListener("DOMContentLoaded",loadDom)
// document.addEventListener("mouseover",highlight)




//AI gadgets
var centerSquares = [27,28,35,36]
var edges = [0,7,15,23,31,39,47,55,63,0,8,16,24,32,40,48,56,1,2,3,
4,5,6,56,57,58,59,60,61,62]
var fianchettoSquares = [9,14,49,54]



function wait(ms){
    var start = new Date().getTime();
    var end = start;
    while(end < start + ms) {
        end = new Date().getTime();
    }
}

function setUpAttackers(){
    squares.forEach(square=>{
        square.attackers = 0
    })
}


function switchTurn(){
    if(currentPlayer==="White's turn"){
            currentPlayer="Black's turn"
            addPieceEventListeners("black")
            removePieceEventListeners("white")
        }
        else{
            currentPlayer="White's turn"
            addPieceEventListeners("white")
            removePieceEventListeners("black")
        }
        countAttackers()
        // console.log(squares[24].attackers)
    player.innerHTML=currentPlayer
    
}
function countAttackers(){
    squares.forEach(square=>{
        if(square.classList.contains("open-square")){
            square.attackers = square.attackers+1
        }
    })
}

// function removeAllEventListenersForWhite(){
//     squares.forEach(square=.{
//         square.removeEventListener("click",whitePawn)
//     })
// }

function loadDom(){
    console.log("calling loadDom")
    createBoard() 
    player.innerHTML=currentPlayer 
    
    squares=document.querySelectorAll(".board div") 
    Array.from(squares).forEach(square=>{ 
    // square.addEventListener("click",whiteClickBox)
    // square.addEventListener("click",blackClickBox)
    })
    playAgain.addEventListener("click",reset)
}

function createBoard(){
    console.log("calling createBoard")
    var black = false;
    for(i=1;i<9;i++){
        black=!black;
        for(j=1;j<9;j++){
            if(!black){
                let div =document.createElement("div") 
                div.setAttribute("data-idx",j) 
                div.setAttribute("data-idy",i) 
                div.setAttribute("squareColor","black") 
                
               
                board.appendChild(div)
            }
            else{
                let div =document.createElement("div") 
                div.setAttribute("data-idx",j) 
                div.setAttribute("data-idy",i) 
                div.setAttribute("squareColor","white") 
                board.appendChild(div)
                ////console.log(div)
                if(i<3){
                    // div.classList.add("taken") 
                    }
                    else if(i>6){
                    // div.classList.add("taken") 
                }
            }
            
            black=!black;
        }
    }
    fillSquareMatrix()
    createPieces()
    
    // addWhitePieceEventListeners()
    addPieceEventListeners("white")
    // setUpEmptySquareListeners()
    // setUpAttackers()    
}



function createPieces(){
    // console.log("calling createPieces")
    // squares =document.querySelectorAll('.board div')
    // let square = squaresMatrix[0][0]
    squaresMatrix[0][0].setAttribute("piece","black-rook")
    squaresMatrix[0][1].setAttribute("piece","black-knight")
    squaresMatrix[0][2].setAttribute("piece","black-bishop")
    squaresMatrix[0][3].setAttribute("piece","black-queen")
    squaresMatrix[0][4].setAttribute("piece","black-king")
    squaresMatrix[0][5].setAttribute("piece","black-bishop")
    squaresMatrix[0][6].setAttribute("piece","black-knight")
    squaresMatrix[0][7].setAttribute("piece","black-rook")
    
    for(i = 8;i<16;i++){
        squares[i].setAttribute("piece","black-pawn")
        // squares[i].setAttribute("piece","hasnt-moved")
    }
    squaresMatrix[7][0].setAttribute("piece","white-rook")
    squaresMatrix[7][1].setAttribute("piece","white-knight")
    squaresMatrix[7][2].setAttribute("piece","white-bishop")
    squaresMatrix[7][3].setAttribute("piece","white-queen")
    squaresMatrix[7][4].setAttribute("piece","white-king")
    squaresMatrix[7][5].setAttribute("piece","white-bishop")
    squaresMatrix[7][6].setAttribute("piece","white-knight")
    squaresMatrix[7][7].setAttribute("piece","white-rook")
    for(i = 48;i<56;i++){
        squares[i].setAttribute("piece","white-pawn")
        //squares[i].classList.add("hasnt-moved")
    }
    
}


function fillSquareMatrix(){
    console.log("setting up squareMatrix")
    squares =document.querySelectorAll('.board div')
        for(i =0;i<8;i++){
            rowToAdd = new Array 
            for(j =0;j<8;j++){
                rowToAdd.push(squares[i*8+j])
            }
            squaresMatrix.push(rowToAdd)
        }
}

function setUpEmptySquareListeners(){
    squares.forEach(square =>{
        square.addEventListener("click",clearPieceSelection)
    })
}

function clearPieceSelection(){
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    if(!(blackPieces.includes(square.classList[1])||whitePieces.includes(square.classList[1]))){
        if(!square.classList.contains("open-square")){
            removeWhiteSelections()
            removeBlackSelections()
        }

    }
}

function evaluate(){
    score = 0
    score+=document.querySelectorAll(".white-pawn").length

    score+= document.querySelectorAll(".white-knight").length*3
    
    score+=document.querySelectorAll(".white-bishop").length*3

    score+=document.querySelectorAll(".white-rook").length*5
    
    score+=document.querySelectorAll(".white-queen").length*9

    score-=document.querySelectorAll(".black-pawn").length

    score-= document.querySelectorAll(".black-knight").length*3
    
    score-=document.querySelectorAll(".black-bishop").length*3

    score-=document.querySelectorAll(".black-rook").length*5
    
    score-=document.querySelectorAll(".black-queen").length*9

    score+=document.querySelectorAll(".white-king").length*100000

    score-=document.querySelectorAll(".black-king").length*100000

    // if(centerSquares.includes())
    centerSquares.forEach(id=>{
        // console.log(squares)
        if(squares[id].classList.contains("white-pawn")){
            // score+=.5*vars[color+"Weight"]
            score+=.5
        }
        else if(squares[id].classList.contains("black-pawn")){
            score-=.5
        }
    })
    // console.log(score)
    centerSquares.forEach(id=>{
        if(whitePieces.includes(squares[id].classList[1])){
            // score+=.5*vars[color+"Weight"]
            score+=.25
        }
        else if(blackPieces.includes(squares[id].classList[1])){
            score-=.25
        }
    })

    edges.forEach(id=>{
        if("white-knight" == squares[id].classList[1]){
            // score+=.5*vars[color+"Weight"]
            score-=.15
        }
        else if("black-knight" == squares[id].classList[1]){
            score+=.15
        }
    })

    fianchettoSquares.forEach(id=>{
        if("white-bishop" == squares[id].classList[1]){
            // score+=.5*vars[color+"Weight"]
            score+=.25
        }
        else if("black-bishop" == squares[id].classList[1]){
            score-=.25
        }
    })

    //castled?

    //whiteJustCastled
    if(whiteCastleableKS==true&&squares[62].classList[1]=="white-king"&&squares[61].classList[1]=="white-rook"){
        score+=.5
    }
    else if(whiteCastleableQS==true&&squares[58].classList[1]=="white-king"&&squares[59].classList[1]=="white-rook"){
        score+=.5
    }
    else if(blackCastleableQS==true&&squares[3].classList[1]=="black-king"&&squares[4].classList[1]=="black-rook"){
        score-=.5
    }
    else if(blackCastleableKS==true&&squares[6].classList[1]=="black-king"&&squares[5].classList[1]=="black-rook"){
        score-=.5
    }


    return score

}


function clickAllColorPieces(color){
    // console.log("calling clickAllColor",color)
    pieces = document.querySelectorAll("."+color+"-knight,."+color+"-pawn,."+color+"-bishop,."+color+"-rook,."+color+"-king,."+color+"-queen")
    let oppositeColor = setOppositeColor(color)
    pieces.forEach(start=>{
        let piece = start.classList[1].slice(6)
        // console.log(start)
        // console.log()
        idx = start.dataset.idx
        idy = start.dataset.idy
        try{
            window[piece+"Movement"](color,start)
            document.querySelectorAll(".open-square").forEach(square=>{
                if(square.classList.contains(oppositeColor+"-king")){
                    square.classList.add("check")
                    // console.log("adding check to",square)
                    // console.log(start)
                    newAttacker = {piece:piece,idx:idx,idy:idy}
                    piecesAttackingKing.push(newAttacker)
                    // console.log(piecesAttackingKing)
                }
            })

        }
        catch(error){
            console.log(error.message)
            console.log(piece)
        }
        document.querySelectorAll(".open-square").forEach(square=>{
            square.classList.remove("open-square")
        })
    })

    // document.querySelectorAll(".open-square").forEach(square=>{
    //     square.classList.add("attacked")
    // })
   
}



function allPossibleColorMoves(color){
    let moves = []
    pieces = document.querySelectorAll("."+color+"-knight,."+color+"-pawn,."+color+"-bishop,."+color+"-rook,."+color+"-king,."+color+"-queen")
    pieces.forEach(start=>{
        piece = start.classList[1]
        
        vars[color+"LastSelectedPiece"] = piece
        vars[color+"LastSelectedLocation"] = 8*(parseInt(start.dataset.idy)-1)+parseInt(start.dataset.idx)-1
        // console.log(piece)
        // console.log(start)
        // console.log(start.classList)
        // clickPiece(color,start)
        idx = start.dataset.idx
        idy = start.dataset.idy
        try{
            window[piece.slice(6)+"Movement"](color,start)

        }
        catch{
            console.log("error calling piece.slice(6) when piece is",piece)
        }
        
        // console.log("IN ALL POSSIBLE, PIECE IS",piece)
        //c
        // 
        // console.log()
        // doesMoveHangColorKing(color)
        

        openSquares = document.querySelectorAll(".open-square")

        // openSquares.forEach(target=>{
            // console.log(target)
        // })
        // openSquares.forEach(target=>{
        //     console.log(target)
        // })
        
        openSquares.forEach(target=>{

            if(piece=="white-pawn"&&target.dataset.idy==1){
                candidate = ({piece:"white-queen",start:start,target:target})
            }
            else if(piece=="black-pawn"&&target.dataset.idy==8){
                candidate = ({piece:"black-queen",start:start,target:target})
            }
            else{
                candidate = ({piece:piece,start:start,target:target})
                // console.log("candidate:",candidate.start.classList)
            }
            if(!doesMoveHangColorKing3(color,candidate)){
                candidate.prune = false
                moves.push(candidate)
            }
            target.classList.remove("open-square")
        })
    })
    // if(moves.length==0){
    //     staleMate(color)
    // }
    // console.log(moves)
    return moves
}

function draw(){
    console.log("calling draw")
    let winner=document.querySelector(".winner")
    winner.innerHTML="draw."
    // currentPlayer.innerHTML=""
    // var x = document.querySelector('.player')
    // x.innerHTML=''
    var span = document.querySelector(".currentPlayer");
    //console.log(span.childNodes[1])
    span.removeChild(span.childNodes[1]);  
}

function oldMinimax(color,moves,depth,alpha,beta){
    // console.log("calling findBestColorMove",color)
    let oppositeColor = setOppositeColor(color)

    if(color=="white"){
        var bestVal = Number.MIN_SAFE_INTEGER
    }
    
    else{
        var bestVal = Number.MAX_SAFE_INTEGER
    }
    // console.log(bestVal)
    //simulate move
    moves.every(move=>{
        // totalMoves+=1
        var temp = ""
        var temp2 = ""
        var tempHolder = false
        var temp2Holder2 = false
        var temp3Holder = false
        var temp3 = ""
        // console.log(move.start.classList)

        var piece = move.start.classList[1]

        
        
        move.start.classList.remove(move.piece)

        if(move.start.classList.contains(color+"-en-passant-pawn")){
            // console.log("triggered temp3")
            temp3Holder = true
            move.start.classList.remove(color+"-en-passant-pawn")

        }


        if(vars[oppositeColor+"Pieces"].includes(move.target.classList[1])){
            tempHolder = true
            // console.log(move.target.classList)
            temp = move.target.classList[1]
            // console.log("removing",temp)

            move.target.classList.remove(temp)
            // console.log(move.target)
            if(move.target.classList[1]==oppositeColor+"-en-passant-pawn"){
                temp2Holder = true
                temp2 = move.target.classList[1]
                move.target.classList.remove(temp2)
            }
            // console.log(bre)
        }
        move.target.classList.add(move.piece)

        //before will evaluate, see if we would be checking the enemy
        
        // move.score = evaluate()
        
        // console.log(move)
        // console.log(move.score)
        // console.log(temp)
        // console.log(move)

        // if we just simulated a white piece moving, then we can clear
        //black en passant pawn
        clearEnPassant(oppositeColor)

        if(depth>1){
            opponentMoves = allPossibleColorMoves(oppositeColor) 
            // console.log(opponentMoves[0])
            bestOpponentMove = oldMinimax(oppositeColor,opponentMoves,depth-1,alpha,beta)
            move.score = bestOpponentMove.score
            // console.log(move.score)
            // console.log(bestOpponentMove)
            // console.log(move.score)
            
            
            
        }
        else{
            move.score = evaluate()
            totalMoves+=1
        }
        
        if(color=="white"){
            // console.log(alpha)
            bestVal = Math.max(bestVal,move.score)
            alpha = Math.max(alpha,move.score)
            if(depth==3){
                // console.log(bestOpponentMove)
                // console.log(move.score)
            }
        }
        else{
            // console.log(beta)
            bestVal = Math.min(bestVal,move.score)
            beta = Math.min(beta,move.score)
        }
        // if(beta<=alpha){
        //     console.log("pruning!")
        //     return
        // }
        
        
        //put pieces back

        if(tempHolder){
            move.target.classList.add(temp)
            if(temp2Holder2){
                move.target.classList.add(temp2)
            }
        }
        
        move.target.classList.remove(move.piece)
        move.target.classList.remove(piece)

        move.start.classList.add(piece)
        if(temp3Holder){
            move.start.classList.add(color+"-en-passant-pawn")
        }

        // if(depth==0)
        //     console.log(bfa)

        // console.log(squares[27].classList)
        // console.log(squares[34].classList)
        // console.log(move.piece)
        // console.log(piece)


    return true;
    })
    moves.sort((a,b)=>{
        return a.score - b.score
    })

    
    return chooseBestMove(color,moves)
    
    

    //     moves.sort((a,b)=>{
    //         return a.score - b.score
    //     })
    // }
    // else{
    //     moves.sort((b,a)=>{
    //         return b.score - a.score
    //     })
    // }
    // console.log(moves)
    // return moves[0]
    // vars[color+"LastSelectedPiece"] = 
    // squares[vars[color+"LastSelectedLocation"]].classList.remove(vars[color+"LastSelectedPiece"])

    //evaluate position
    //store evaluation in move
}

function test1(){
    squares[0].setAttribute("attribute","test")
    squares[1].setAttribute("attribute","test")
    console.log(squares[0])
    elements = document.querySelectorAll('[attribute="test"]');
    console.log(elements)
}

// function test12(){
//     console.log(test)
//     consol.log(bre)
// }



function colorAI(color){
    test1()
    console.log(brea)
    // test12()

    console.log("moving",color,"with AI")
    totalMoves = 0
    // let moves = allPossibleColorMoves(color)
    // console.log(moves[0])
    // console.log(asdf)
    bestMove = minimax2(color,1,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)
    // console.log(bestMove)
    vars[color+"LastSelectedPiece"] = bestMove.piece
    vars[color+"LastSelectedLocation"] = 8*(parseInt(bestMove.start.dataset.idy)-1)+parseInt(bestMove.start.dataset.idx)-1

    // console.log(vars[color+"LastSelectedPiece"] )
    // console.log(bestMove.start)
    movePiece(color,bestMove.target)

    // checkForDraw()
    console.log("TOTAL MOVES =",totalMoves)
    
    
}


function checkForDraw(){
    //there are obvious more endgames that are drawn with perfect play,
    //but we aren't going to assume anyone will play perfect
    
}

// nums = [1,2,3,4]
// nums.every(num=>{

//     if(num==2)
//         return false

//     console.log(num)
//     return true
// })


//depth is counted in "ply", which is either white or black moving (not both)
//this is a bounded depth first search algorithm that finds and evaluates all possible
//positions after a certain amount of moves
function minimax2(color,depth,alpha,beta){
    clearAttacked()
    let moves = allPossibleColorMoves(color)
    clearAttacked()
    // console.log("calling findBestColorMove",color)
    let oppositeColor = setOppositeColor(color)

    if(color=="white"){
        var bestVal = Number.MIN_SAFE_INTEGER
    }
    
    else{
        var bestVal = Number.MAX_SAFE_INTEGER
    }
    // console.log(bestVal)
    //simulate move
    var pruning = false
    moves.every(move=>{


        if(depth==3){
            // console.log("WHITE WILL NOW BEGIN EXPLORING",move,"on move 1")
            // console.log("a = ",alpha)
            // console.log("b = ",beta)
        }
        // var mmtemp = ""
        // var mmtemp2 = ""
        // var mmtempHolder = false
        // var mmtemp2Holder = false
        // var mmtemp3Holder = false
        // var mmtemp3 = ""
        // totalMoves+=1
        // var temp = ""
        // var temp2 = ""
        var tempHolder = false
        var temp2Holder = false
        var temp3Holder = false
        // var temp3 = ""
        // // console.log(move.start.classList)
        // console.log(move)
        var piece = move.start.classList[1]

        
        // tempList = move.start.classList.slice(1,2)

        move.start.classList.remove(move.piece)
        // move.start.classList.remove(move.start.classList.slice(1,))
        console.log(move.start.classList)
        // move.start.classList.add(tempList)
        console.log(move.start.classList)

        
        // if(move.start.classList.contains(color+"-en-passant-pawn")){
        //     // console.log("triggered temp3")
        //     temp3Holder = true
        //     move.start.classList.remove(color+"-en-passant-pawn")
        // }
        classList2Holder = move.start.classList[2]
        // console.log(classList2Holder)
        if(vars[oppositeColor+"Pieces"].includes(move.target.classList[1])){
            tempHolder = true
            // console.log(move.target.classList)
            temp = move.target.classList[1]
            // console.log("removing",temp)

            move.target.classList.remove(temp)
            // console.log(move.target)
            if(move.target.classList[1]==oppositeColor+"-en-passant-pawn"){
                temp2Holder = true
                temp2 = move.target.classList[1]
                move.target.classList.remove(temp2)
            }
           

            // console.log(bre)
        }
        move.target.classList.add(move.piece)

        //before will evaluate, see if we would be checking the enemy
        
        // move.score = evaluate()
        
        // console.log(move)
        // console.log(move.score)
        // console.log(temp)
        // console.log(move)

        // if we just simulated a white piece moving, then we can clear
        //black en passant pawn
        clearEnPassant(oppositeColor)
        clearAttacked()
        // let temp, temp2, temp3, tempHolder, temp2Holder, temp3Holder, piece = makeMove(color,move)
        // makeMove(color,move)
        // console.log(move)
        // console.log(temp)
        // console.log(temp2)

        // console.log(temp3)

        // console.log(tempHolder)
        // console.log(temp2Holder)
        // console.log(temp3Holder)
        // console.log(piece)


        if(depth>1){
            // opponentMoves = allPossibleColorMoves(oppositeColor) 
            // console.log(opponentMoves[0])
            bestOpponentMove = minimax2(oppositeColor,depth-1,alpha,beta)
            clearAttacked()
            // console.log("bom=",bestOpponentMove)
            move.score = bestOpponentMove.score
            move.bom = bestOpponentMove
            if(bestOpponentMove.prune==true){
                move.prune =true
                // console.log("just pruned when searching",move)
            }
            // console.log(bestOpponentMove)
            // console.log(move.score)
        }
        else{
            move.score = evaluate()
            totalMoves+=1
            // if(move.piece==color+"-knight"&&move.target==squares[21]){
            //     console.log(asdf)
            //     // console.log(asdf)
                
            // }
            // console.log()
        }
        if(color=="white"){
            // console.log(alpha)
            // console.log("white is choosing")
            // if(depth==3){
                bestVal = Math.max(bestVal,move.score)
                alpha = Math.max(alpha,move.score)
            // }
            // if(depth==3)
            //     console.log(asdf)
                // console.log(bestOpponentMove)
                // console.log(move.score)
                
                // console.log("white is exploring",move)
                // console.log(alpha)
            // }
        }
        else if(color == "black"){
            // console.log(beta)
            // console.log("black was exploring",move,"assuming white will play")
            // console.log("a = ",alpha)
            // console.log("b = ",beta)
            bestVal = Math.min(bestVal,move.score)
            beta = Math.min(beta,move.score)
            // console.log("b=",beta)
        }
        // if(depth==1){
        //     console.log(move)
        //     console.log("a = ",alpha)
        //     console.log("b = ",beta)
        // }
        
        
        
        
        //put pieces back
        // returnMove(color,move)
        if(tempHolder){
            move.target.classList.add(temp)
            if(temp2Holder){
                move.target.classList.add(temp2)
            }
        }
        
        move.target.classList.remove(move.piece)
        move.target.classList.remove(piece)
        // console.log("returning ",piece,"to",move.start)
        move.start.classList.add(piece)
        // if(temp3Holder){
        //     move.start.classList.add(color+"-en-passant-pawn")
        // }
        // console.log(classList2Holder)
        if(typeof classList2Holder!="undefined"){
            // temp = move.start.classList[1]
            console.log("needed to add",classList2Holder,"to",move.start)
            move.start.classList.add(classList2Holder)


        }

        clearAttacked()
  
        // console.log(squares[27].classList)
        // console.log(squares[34].classList)
        // console.log(move.piece)
        // console.log(piece)
        if(beta<=alpha){
            
            // console.log("pruning!")

            // console.log(color,"was exploring",move,"at depth",depth,"assuming opponent would play",bestOpponentMove)
            // console.log("a = ",alpha)
            // console.log("b = ",beta)
            // console.log(moves)
            
            pruning = true
            move.prune = true
            pruneMove = move
            return
        }

    return true;

    })
    if(pruning){
    //     moves.forEach(move2=>{
    //     if(!move2.prune){
    //         console.log("actual move")
    //         console.log(move2)
    //     }
    // })
        return pruneMove
    }
    moves.sort((a,b)=>{
        return a.score - b.score
    })

    // if(color == "black"){
    //     console.log("after pruning,")
    //     console.log("a=",alpha)
    //     console.log("b=",beta)
    // }
    

    bm = chooseBestMove(color,moves)
    // if(depth==3){
    //     console.log("WHITE JUST EXPLORED",move,"on move 1")
    // }
    // if(depth==1)
    //     console.log("bm=",bm)
    return chooseBestMove(color,moves)
    
    

    //     moves.sort((a,b)=>{
    //         return a.score - b.score
    //     })
    // }
    // else{
    //     moves.sort((b,a)=>{
    //         return b.score - a.score
    //     })
    // }
    // console.log(moves)
    // return moves[0]
    // vars[color+"LastSelectedPiece"] = 
    // squares[vars[color+"LastSelectedLocation"]].classList.remove(vars[color+"LastSelectedPiece"])

    //evaluate position
    //store evaluation in move
}

function returnMove(color,move){
    if(tempHolder){
        move.target.classList.add(temp)
        if(temp2Holder){
            move.target.classList.add(temp2)
        }
    }
    
    move.target.classList.remove(move.piece)
    move.target.classList.remove(piece)

    move.start.classList.add(piece)
    if(temp3Holder){
        move.start.classList.add(color+"-en-passant-pawn")
    }
}

function makeMove(color,move){
        let oppositeColor = setOppositeColor()
        // totalMoves+=1
        
        // console.log(move.start.classList)

        

        
        
        move.start.classList.remove(move.piece)

        if(move.start.classList.contains(color+"-en-passant-pawn")){
            // console.log("triggered temp3")
            temp3Holder = true
            move.start.classList.remove(color+"-en-passant-pawn")

        }
        if(vars[oppositeColor+"Pieces"].includes(move.target.classList[1])){
            tempHolder = true
            // console.log(move.target.classList)
            temp = move.target.classList[1]
            // console.log("removing",temp)

            move.target.classList.remove(temp)
            // console.log(move.target)
            if(move.target.classList[1]==oppositeColor+"-en-passant-pawn"){
                temp2Holder = true
                temp2 = move.target.classList[1]
                move.target.classList.remove(temp2)
            }
            // console.log(bre)
        }
        move.target.classList.add(move.piece)

        //before will evaluate, see if we would be checking the enemy
        
        // move.score = evaluate()
        
        // console.log(move)
        // console.log(move.score)
        // console.log(temp)
        // console.log(move)

        // if we just simulated a white mmpiece moving, then we can clear
        //black en passant pawn
        clearEnPassant(oppositeColor)
    }
//alpha is the best value that white can guarantee at the current depth, or above
//beta is the best value that black can guarantee at the current depth, or abve
function minimax(color,moves,depth,alpha,beta){
    // console.log("calling findBestColorMove",color)
    let oppositeColor = setOppositeColor(color)

    if(color=="white"){
        var bestVal = Number.MIN_SAFE_INTEGER
    }
    
    else{
        var bestVal = Number.MAX_SAFE_INTEGER
    }
    // console.log(bestVal)
    //simulate move
    var pruning = false
    moves.every(move=>{

        if(depth==3){
            console.log("WHITE WILL NOW BEGIN EXPLORING",move,"on move 1")
            console.log("a = ",alpha)
            console.log("b = ",beta)
        }
        
        // totalMoves+=1
        var temp = ""
        var temp2 = ""
        var tempHolder = false
        var temp2Holder2 = false
        var temp3Holder = false
        var temp3 = ""
        // console.log(move.start.classList)

        var piece = move.start.classList[1]

        
        
        move.start.classList.remove(move.piece)

        if(move.start.classList.contains(color+"-en-passant-pawn")){
            // console.log("triggered temp3")
            temp3Holder = true
            move.start.classList.remove(color+"-en-passant-pawn")

        }


        if(vars[oppositeColor+"Pieces"].includes(move.target.classList[1])){
            tempHolder = true
            // console.log(move.target.classList)
            temp = move.target.classList[1]
            // console.log("removing",temp)

            move.target.classList.remove(temp)
            // console.log(move.target)
            if(move.target.classList[1]==oppositeColor+"-en-passant-pawn"){
                temp2Holder = true
                temp2 = move.target.classList[1]
                move.target.classList.remove(temp2)
            }
            // console.log(bre)
        }
        move.target.classList.add(move.piece)

        //before will evaluate, see if we would be checking the enemy
        
        // move.score = evaluate()
        
        // console.log(move)
        // console.log(move.score)
        // console.log(temp)
        // console.log(move)

        // if we just simulated a white piece moving, then we can clear
        //black en passant pawn
        clearEnPassant(oppositeColor)

        if(depth>1){
            opponentMoves = allPossibleColorMoves(oppositeColor) 
            // console.log(opponentMoves[0])
            
            bestOpponentMove = minimax(oppositeColor,opponentMoves,depth-1,alpha,beta)
            // console.log("bom=",bestOpponentMove)
            move.score = bestOpponentMove.score
            // console.log(move.score)
            // console.log(bestOpponentMove)
            // console.log(move.score)
        }
        else{
            move.score = evaluate()
            totalMoves+=1
            console.log()
        }
        
        if(color=="white"){
            // console.log(alpha)
            // console.log("white is choosing")
            // if(depth==3){
                bestVal = Math.max(bestVal,move.score)
                alpha = Math.max(alpha,move.score)
            // }
            // if(depth==3)
            //     console.log(asdf)
                // console.log(bestOpponentMove)
                // console.log(move.score)
                
                // console.log("white is exploring",move)
                // console.log(alpha)
            // }
        }
        else if(color == "black"){
            // console.log(beta)
            console.log("black was exploring",move,"assuming white will play",bestOpponentMove)
            console.log("a = ",alpha)
            console.log("b = ",beta)
            bestVal = Math.min(bestVal,move.score)
            beta = Math.min(beta,move.score)
            // console.log("b=",beta)
        }
        
        // if(depth==1){
        //     console.log(move)
        //     console.log("a = ",alpha)
        //     console.log("b = ",beta)
        // }
        if(depth==3){
            // console.log(moves)
            console.log("WHITE FOUND",move,"at 1 ply assuming black plays",bestOpponentMove)

        }
        
        
        
        //put pieces back

        if(tempHolder){
            move.target.classList.add(temp)
            if(temp2Holder2){
                move.target.classList.add(temp2)
            }
        }
        
        move.target.classList.remove(move.piece)
        move.target.classList.remove(piece)

        move.start.classList.add(piece)
        if(temp3Holder){
            move.start.classList.add(color+"-en-passant-pawn")
        }

        // if(depth==0)
        //     console.log(bfa)

        // console.log(squares[27].classList)
        // console.log(squares[34].classList)
        // console.log(move.piece)
        // console.log(piece)
        if(beta<=alpha){
            
            // console.log("pruning!")

            // console.log(color,"was exploring",move,"at depth",depth,"assuming opponent would play",bestOpponentMove)
            // console.log("a = ",alpha)
            // console.log("b = ",beta)
            // console.log("a=",alpha)
            // console.log("b=",beta)
            pruning = true
            move.score-=.05
            pruneMove = move

            return
        }

    return true;
    })
    if(pruning){
        return pruneMove
    }
    moves.sort((a,b)=>{
        return a.score - b.score
    })

    // if(color == "black"){
    //     console.log("after pruning,")
    //     console.log("a=",alpha)
    //     console.log("b=",beta)
    // }
    

    bm = chooseBestMove(color,moves)
    // if(depth==3){
    //     console.log("WHITE JUST EXPLORED",move,"on move 1")
    // }
    // if(depth==1)
    //     console.log("bm=",bm)
    return chooseBestMove(color,moves)
    
    

    //     moves.sort((a,b)=>{
    //         return a.score - b.score
    //     })
    // }
    // else{
    //     moves.sort((b,a)=>{
    //         return b.score - a.score
    //     })
    // }
    // console.log(moves)
    // return moves[0]
    // vars[color+"LastSelectedPiece"] = 
    // squares[vars[color+"LastSelectedLocation"]].classList.remove(vars[color+"LastSelectedPiece"])

    //evaluate position
    //store evaluation in move
}

// [1,1,1,0,0,0,0,0,-1,-1,-1]


function chooseBestMove(color,moves){

    moves2 = []
    // console.log(moves)
    moves.forEach(move=>{
        if(move.prune==false){
            moves2.push(move)
        }
        else{
            // console.log(move)
        }
        // console.log(move.prune)
    })
    // return moves2[0]
    // console.log(moves2)
    // console.log(moves)
    // console.log(moves2)
    // console.log(moves2.length)
    if(moves2.length==1){
    //     console.log("choosing random move...")
        // return moves[Math.floor(Math.random()*moves.length)]
        return moves2[0]
    }

    bestMoves = []
    if(color=="black"){
        return moves2[0]
        // console.log(moves)
        if(moves2[0].score<moves2[moves2.length-1].score){
            let i = 1
            bestMoves.push(moves2[0])
            bestScore = moves2[0].score
            while(moves2[i].score==bestScore){
                // bestMoves.push(moves[i])
                i+=1
            }
            // console.log(bestMoves)
            return bestMoves[Math.floor(Math.random()*bestMoves.length)]
        }
    }
    else if(color=="white"){
        return moves2[moves2.length-1]
        // console.log(moves)
        if(moves2[0].score<moves2[moves2.length-1].score){
            let i = 1
            bestMoves.push(moves2[moves2.length-1])
            bestScore = moves2[moves2.length-1].score
            // console.log(bestScore)
            while(moves2[moves2.length-1-i].score==bestScore){
                bestMoves.push(moves2[moves2.length-1-i])
                i+=1
            }
            console.log(bestMoves)
            return bestMoves[Math.floor(Math.random()*bestMoves.length)]
        }
            // return moves[moves.length-1]
    }
    // console.log("choosing random")
    return moves2[Math.floor(Math.random()*moves.length)]
    console.log("this should never print")
    return moves[0]
}

function whatSquaresCanColorAttack(color){
    Pawns = document.querySelectorAll("."+color+"-pawn")

    Pawns.forEach(square=>{
        clickPiece(color,square)
    })

    Knights = document.querySelectorAll("."+color+"-knight")
    Knights.forEach(square=>{
        clickPiece(color,square)
    })

    Bishops = document.querySelectorAll("."+color+"-bishop")
    Bishops.forEach(square=>{
        clickPiece(color,square)
    })

    Rooks = document.querySelectorAll("."+color+"-rook")
    Rooks.forEach(square=>{
        clickPiece(color,square)
    })

    King = document.querySelectorAll("."+color+"-king")
    King.forEach(square=>{
        clickPiece(color,square)
    })

    Queen = document.querySelectorAll("."+color+"-queen")
    Queen.forEach(square=>{
        clickPiece(color,square)
    })
    vars["squares"+color+"CanAttack"] = document.querySelectorAll("open-square")
}



function whiteHighlight(){
    console.log("calling whiteHighlight")
    // //console.log("calling highlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    // if(square.classList.contains("open-square")){
        if(square.classList[0]==="blackSquare"){
        square.classList.add("highlight-dark")
            }
            else{
                square.classList.add("highlight-light")
        }
    // }
}

function whiteUnhighlight(){
    console.log("calling whiteUnhighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    if(square.classList[0]==="blackSquare"){
        square.classList.remove("highlight-dark")
    }
    else{
        square.classList.remove("highlight-light")
    }
}



async function whitePawnPromotion(squareIndex){
    
    console.log(squares[squareIndex])
    console.log("calling squareIndex")
    // document.addEventListener("mouseover",whitePawnPromotion)
    // squares.forEach(square =>{
    //     square.removeEventListener("click",whiteClickBox)
    // })
    square = squares[arguments[0]]
        square.classList.remove("white-pawn")
        // square.classList.add("white-queen")
        square.classList.add("prom-white-queen")
        //console.log(square.classList)
        squares[arguments[0]+8].classList.add("prom-white-knight")
        //console.log(squares[arguments[0]+8].classList)
        squares[arguments[0]+16].classList.add("prom-white-rook")
        squares[arguments[0]+24].classList.add("prom-white-bishop")
        // squares[arguments[0]+8].addEventListener(pawnHighlight)
        square.classList.add("pawn-promotion")
        square.addEventListener("mouseover",whitePawnHighlight)
        squares[arguments[0]+8].addEventListener("mouseover",whitePawnHighlight)
        squares[arguments[0]+16].addEventListener("mouseover",whitePawnHighlight)
        squares[arguments[0]+24].addEventListener("mouseover",whitePawnHighlight)
        square.addEventListener("mouseout",whitePawnUnhighlight)
        squares[arguments[0]+8].addEventListener("mouseout",whitePawnUnhighlight)
        squares[arguments[0]+16].addEventListener("mouseout",whitePawnUnhighlight)
        squares[arguments[0]+24].addEventListener("mouseout",whitePawnUnhighlight)
        square.addEventListener("click",whitePromotionChooser)
        squares[arguments[0]+8].addEventListener("click",whitePromotionChooser)
        squares[arguments[0]+16].addEventListener("click",whitePromotionChooser)
        squares[arguments[0]+24].addEventListener("click",whitePromotionChooser)
        //console.log(square.classList)
    
    

    // if(MouseEvent===onclick){
    //     square.classList.remove("pawn-promotion")
    //     squares[arguments[0]+8].classList.remove("pawn-promotion")
    //     squares[arguments[0]+16].classList.remove("pawn-promotion")
    //     squares[arguments[0]+24].classList.remove("pawn-promotion")
    // }
}


    
    


async function whitePromotionChooser(){
    // return new Promise((resolve,reject)=>{
    //here our function should be implemented 
        // setTimeout(()=>{
            // console.log(square)
            console.log("calling whitePromotionChooser")
            let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
        //console.log(square.classList)
            //console.log(parseInt(this.dataset.idy))
            square.classList.remove("pawn-promotion")
            if(parseInt(this.dataset.idy)-1==0){
                square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
                square.classList.add("white-queen")
                square.classList.remove("prom-white-queen")
                
                //console.log("you chose queen")
                squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-knight")
                squares[8*(parseInt(this.dataset.idy)-1+2)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-rook")
                squares[8*(parseInt(this.dataset.idy)-1+3)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-bishop")
                // square.classList.remove("pawn-promotion")
            }
            else if(parseInt(this.dataset.idy)-1==1){
                square = squares[8*(parseInt(this.dataset.idy)-1-1)+parseInt(this.dataset.idx)-1]
                square.classList.remove("prom-white-queen")
                square.classList.add("white-knight")
                //console.log(square.classList)
                //console.log("you chose knight")
                squares[8*(parseInt(this.dataset.idy)-1+0)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-knight")
                squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-rook")
                squares[8*(parseInt(this.dataset.idy)-1+2)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-bishop")
            }
            else if(parseInt(this.dataset.idy)-1==2){
                square = squares[8*(parseInt(this.dataset.idy)-1-2)+parseInt(this.dataset.idx)-1]
                square.classList.remove("prom-white-queen")
                square.classList.add("white-rook")
                //console.log(square.classList)
                squares[8*(parseInt(this.dataset.idy)-1-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-knight")
                squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-rook")
                squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-bishop")
                //console.log("you chose rook")
            }
            else if(parseInt(this.dataset.idy)-1==3){
                square = squares[8*(parseInt(this.dataset.idy)-1-3)+parseInt(this.dataset.idx)-1]
                square.classList.remove("prom-white-queen")
                square.classList.add("white-bishop")
                square.classList.remove("pawn-promotion")
                squares[8*(parseInt(this.dataset.idy)-1-2)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-knight")
                squares[8*(parseInt(this.dataset.idy)-1-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-rook")
                squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-white-bishop")
                //console.log("you chose bishop")
            }
            // square.classList.remove("pawn-promotion")
            switchTurn()
            squares.forEach(square =>{
                // square.addEventListener("click",blackClickBox)
                square.removeEventListener("click",whitePromotionChooser)
                square.removeEventListener("mouseover",whitePawnHighlight)
                square.removeEventListener("mouseout",whitePawnUnhighlight)

            })
            
            isBlackKinginCheck(document.getElementsByClassName("black-king")[0])
            if(document.getElementsByClassName("black-king")[0].classList.contains("check")){
                didBlackGetMated()
            }
            if(whiteWon){
                whiteWins()
            }
            console.log("ending white promotion chooser")
            
}

function whitePawnHighlight(){
    console.log("calling whitePawnHighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    square.classList.add("pawn-promotion")
// //console.log(square.classList)

}

function whitePawnUnhighlight(){
    console.log("calling whitePawnUnhighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    square.classList.remove("pawn-promotion")
    // //console.log(square.classList)
}

function blackHighlight(){
    // //console.log("calling highlight")
    console.log("calling blackHighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    // if(square.classList.contains("open-square")){
        if(square.classList[0]==="blackSquare"){
        square.classList.add("highlight-dark")
            }
            else{
                square.classList.add("highlight-light")
        }
    // }
}

function blackUnhighlight(){
    console.log("calling blackUnhighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    if(square.classList[0]==="blackSquare"){
        square.classList.remove("highlight-dark")
            }
            else{
                square.classList.remove("highlight-light")
        }
}



function blackPawnPromotion(squareIndex){
    console.log("calling blackPawnPromotion")
    // document.addEventListener("mouseover",whitePawnPromotion)

    squares.forEach(square =>{
        square.removeEventListener("click",blackClickBox)
    })
    square = squares[arguments[0]]
    
    
        square.classList.remove("black-pawn")
        square.classList.add("prom-black-queen")
        //console.log(square.classList)
        squares[arguments[0]-8].classList.add("prom-black-knight")
        //console.log(squares[arguments[0]-8].classList)
        squares[arguments[0]-16].classList.add("prom-black-rook")
        squares[arguments[0]-24].classList.add("prom-black-bishop")
        // squares[arguments[0]+8].addEventListener(pawnHighlight)
        square.classList.add("pawn-promotion")
        square.addEventListener("mouseover",blackPawnHighlight)
        squares[arguments[0]-8].addEventListener("mouseover",blackPawnHighlight)
        squares[arguments[0]-16].addEventListener("mouseover",blackPawnHighlight)
        squares[arguments[0]-24].addEventListener("mouseover",blackPawnHighlight)
        square.addEventListener("mouseout",blackPawnUnhighlight)
        squares[arguments[0]-8].addEventListener("mouseout",blackPawnUnhighlight)
        squares[arguments[0]-16].addEventListener("mouseout",blackPawnUnhighlight)
        squares[arguments[0]-24].addEventListener("mouseout",blackPawnUnhighlight)
        square.addEventListener("click",blackPromotionChooser)
        squares[arguments[0]-8].addEventListener("click",blackPromotionChooser)
        squares[arguments[0]-16].addEventListener("click",blackPromotionChooser)
        squares[arguments[0]-24].addEventListener("click",blackPromotionChooser)
        //console.log(square.classList)
    
    

    // if(MouseEvent===onclick){
    //     square.classList.remove("pawn-promotion")
    //     squares[arguments[0]+8].classList.remove("pawn-promotion")
    //     squares[arguments[0]+16].classList.remove("pawn-promotion")
    //     squares[arguments[0]+24].classList.remove("pawn-promotion")
    // }
}

async function blackPromotionChooser(){
    console.log("calling blackPromotionChooser")
    
    //console.log("blackPromotionChooser")

    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    //console.log(square.classList)
    //console.log(parseInt(this.dataset.idy))
    square.classList.remove("pawn-promotion")
    if(parseInt(this.dataset.idy)-1==7){
        square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
        square.classList.remove("prom-black-queen")
        square.classList.add("black-queen")
        //console.log("you chose queen")
            squares[8*(parseInt(this.dataset.idy)-1-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-knight")
            squares[8*(parseInt(this.dataset.idy)-1-2)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-rook")
            squares[8*(parseInt(this.dataset.idy)-1-3)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-bishop")
        // square.classList.remove("pawn-promotion")
    }
    else if(parseInt(this.dataset.idy)-1==6){
        square = squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1]
        square.classList.remove("prom-black-queen")
        square.classList.add("black-knight")
        //console.log(square.classList)
        //console.log("you chose knight")
        squares[8*(parseInt(this.dataset.idy)-1-0)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-knight")
        squares[8*(parseInt(this.dataset.idy)-1-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-rook")
        squares[8*(parseInt(this.dataset.idy)-1-2)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-bishop")
    }
    else if(parseInt(this.dataset.idy)-1==5){
        square = squares[8*(parseInt(this.dataset.idy)-1+2)+parseInt(this.dataset.idx)-1]
        square.classList.remove("prom-black-queen")
        square.classList.add("black-rook")
        //console.log(square.classList)
            squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-knight")
            squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-rook")
            squares[8*(parseInt(this.dataset.idy)-1-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-bishop")
        //console.log("you chose rook")
    }
    else if(parseInt(this.dataset.idy)-1==4){
        square = squares[8*(parseInt(this.dataset.idy)-1+3)+parseInt(this.dataset.idx)-1]
        square.classList.remove("prom-black-queen")
        square.classList.add("black-bishop")
        square.classList.remove("pawn-promotion")
            squares[8*(parseInt(this.dataset.idy)-1+2)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-knight")
            squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-rook")
            squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1].classList.remove("prom-black-bishop")
        //console.log("you chose bishop")
    }
    // square.classList.remove("pawn-promotion")
    
    
    squares.forEach(square =>{
        // square.addEventListener("click",whiteClickBox)
        square.removeEventListener("click",blackPromotionChooser)
        square.removeEventListener("mouseover",blackPawnHighlight)
        square.removeEventListener("mouseout",blackPawnUnhighlight)

    })
    isWhiteKinginCheck(document.getElementsByClassName("white-king")[0])
    if(document.getElementsByClassName("white-king")[0].classList.contains("check")){
            didWhiteGetMated()
    }
    if(blackWon){
        blackWins()
    }
    return
}

function blackPawnHighlight(){
    console.log("calling blackPawnHighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    square.classList.add("pawn-promotion")
// //console.log(square.classList)

}

function blackPawnUnhighlight(){
    console.log("calling blackPawnUnhighlight")
    let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
    square.classList.remove("pawn-promotion")
    // //console.log(square.classList)
}


function didBlackGetMated(){
    console.log("calling didBlackGetMated")
    allPossibleMoves = []
    squares.forEach(square=>{
        if(square.classList.contains("black-pawn")){
            // //console.log("found one")
            // //console.log(square)

            blackPawn(square)
            blackLastSelectedPiece = square.classList[1]
            blackLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangBlackKing(true)


            
        }
        else if(square.classList.contains("black-bishop")){
            // //console.log("found one")
            // //console.log(square)

            blackBishop(square)
            blackLastSelectedPiece = square.classList[1]
            blackLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangBlackKing(true)


            
        }
        else if(square.classList.contains("black-rook")){
            // //console.log("found one")
            // //console.log(square)

            blackRook(square)
            blackLastSelectedPiece = square.classList[1]
            blackLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangBlackKing(true)


            
        }
        else if(square.classList.contains("black-knight")){
            // //console.log("found one")
            // //console.log(square)

            blackKnight(square)
            blackLastSelectedPiece = square.classList[1]
            blackLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangBlackKing(true)


            
        }
        else if(square.classList.contains("black-queen")){
            // //console.log("found one")
            // //console.log(square)
            blackQueen(square)
            blackLastSelectedPiece = square.classList[1]
            blackLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangBlackKing(true)

        }
        else if(square.classList.contains("black-king")){
            // //console.log("found one")
            // //console.log(square)
            blackLastSelectedPiece = square.classList[1]
            blackLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            blackKing(square)
            doesMoveHangBlackKing(true)

        }
        openSquares = document.getElementsByClassName("open-square")
        for(let square of openSquares){
            allPossibleMoves.push(square)
            square.classList.remove("open-square")
        }
    })
    
    if(allPossibleMoves.length==0){
        whiteWon = true
    }
    
}

function didColorGetMated2(color){
    console.log("calling didColorGetMated2")
    moves = allPossibleColorMoves(color)
    if(moves.length==0)
        colorWins(setOppositeColor(color))

}

function didColorGetMated(color){
    console.log("calling didColorGetMated",color)
    allPossibleMoves = []
    pawns = document.querySelectorAll("."+color+"-pawn")
    
    pawns.forEach(square=>{
        clickPiece(color,square)
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        // openSquares = document.getElementsByClassName("open-square")
        doesMoveHangColorKing(color,true)
    })

    knights = document.querySelectorAll("."+color+"-knight")
    knights.forEach(square=>{
        clickPiece(color,square)
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        doesMoveHangColorKing(color)
    })

    bishops = document.querySelectorAll("."+color+"-bishop")
    bishops.forEach(square=>{
        clickPiece(color,square)
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        doesMoveHangColorKing(color)
    })

    rooks = document.querySelectorAll("."+color+"-rook")
    rooks.forEach(square=>{
        clickPiece(color,square)
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        doesMoveHangColorKing(color)
    })

    king = document.querySelectorAll("."+color+"-king")
    king.forEach(square=>{
        clickPiece(color,square)
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        doesMoveHangColorKing(color)
    })

    queen = document.querySelectorAll("."+color+"-queen")
    queen.forEach(square=>{
        clickPiece(color,square)
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        doesMoveHangColorKing(color)
    })

    let openSquares =  document.querySelectorAll(".open-square")
    console.log(openSquares.length)
    openSquares.forEach(square=>{
        console.log(square)
        allPossibleMoves.push(square)
        square.classList.remove("open-square")
    })
    
    if(allPossibleMoves.length==0){
        colorWins(setOppositeColor(color))
    }
    
}

function didWhiteGetMated(){
    console.log("calling didWhiteGetMated")
    allPossibleMoves = []
    squares.forEach(square=>{
        if(square.classList.contains("white-pawn")){
            // //console.log("found one")
            // //console.log(square)

            whitePawn(square)
            // whiteLastSelectedPiece = square.classList[1]
            whiteLastSelectedPiece =  square.classList[1]
            whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangWhiteKing(true)


            
        }
        else if(square.classList.contains("white-bishop")){
            // //console.log("found one")
            // //console.log(square)

            whiteBishop(square)
            whiteLastSelectedPiece = square.classList[1]
            whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangWhiteKing(true)


            
        }
        else if(square.classList.contains("white-rook")){
            // //console.log("found one")
            // //console.log(square)

            whiteRook(square)
            whiteLastSelectedPiece = square.classList[1]
            whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangWhiteKing(true)


            
        }
        else if(square.classList.contains("white-knight")){
            // //console.log("found one")
            // //console.log(square)

            whiteKnight(square)
            whiteLastSelectedPiece = square.classList[1]
            whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangWhiteKing(true)


            
        }
        else if(square.classList.contains("white-queen")){
            // //console.log("found one")
            // //console.log(square)
            whiteQueen(square)
            whiteLastSelectedPiece = square.classList[1]
            whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            doesMoveHangWhiteKing(true)

        }
        else if(square.classList.contains("white-king")){
            // //console.log("found one")
            // //console.log(square)
            whiteLastSelectedPiece = square.classList[1]
            whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
            whiteKing(square)
            doesMoveHangWhiteKing(true)

        }
        openSquares = document.getElementsByClassName("open-square")
        for(let square of openSquares){
            allPossibleMoves.push(square)
            square.classList.remove("open-square")
            square.classList.remove("selecting-dark")
        }
        
        // square.classList.remove("open-square")
    })
    
    if(allPossibleMoves.length==0){
        blackWon = true
    }
    
}

function isBlackKinginCheck(square){
    console.log("calling isBlackKinginCheck")
    

    squares.forEach(square=>{
        if(square.classList.contains("white-pawn")){
            // //console.log("found one")
            // //console.log(square)

            whitePawn(square)
            
        }
        if(square.classList.contains("white-bishop")){
            // //console.log("found one")
            // //console.log(square)

            whiteBishop(square)
            
        }
        if(square.classList.contains("white-rook")){
            // //console.log("found one")
            // //console.log(square)

            whiteRook(square)
            
        }
        if(square.classList.contains("white-knight")){
            // //console.log("found one")
            // //console.log(square)

            whiteKnight(square)
            
        }
        if(square.classList.contains("white-queen")){
            // //console.log("found one")
            // //console.log(square)
            whiteQueen(square)
        }
        if(square.classList.contains("white-king")){
            // //console.log("found one")
            // //console.log(square)

            whiteKing(square)
            
        }
        // square.classList.remove("open-square")
    })
    blackPiecesToCapture()
    // countAttackers()
    // blackPiecesToCapture()
    // if(document.getElementsByClassName("black-king")[0].classList.contains("capturable-light")
    // ||document.getElementsByClassName("black-king")[0].classList.contains("capturable-dark")){
    //     //console.log("black king now in check")
    //     document.getElementsByClassName("black-king")[0].classList.add("check")
    // }
    square.classList.remove("check")
    
    //     square.classList.contains("capturable-light")
    // ||square.classList.contains("capturable-dark"
    if(square.classList.contains("open-square")){
        //console.log("black king now in check")
        square.classList.add("check")
    }

        //comment out to see all potential moves
    // openSquares = document.querySelectorAll(".open-square")
    // openSquares.forEach(square=>{
    //     console.log(square)
    // })
    squares.forEach(square=>{
        //console.log("removing castleable")

        square.classList.remove("open-square")
        square.classList.remove("selecting-light")
        square.classList.remove("selecting-dark")
        square.classList.remove("capturable-light")
        square.classList.remove("capturable-dark")
        square.classList.remove("castleable-light")
        square.classList.remove("castleable-dark")
        // removeWhiteSelections()
        // removeBlackSelections()
        // clearPrevious()
        square.removeEventListener("click",whiteMoving)
        // square.removeEventListener("click",blackMoving)


        square.classList.remove("castleable-light")
        square.classList.remove("castleable-dark")
    })

}

function isWhiteKinginCheck(square){
    console.log("calling isWhiteKingInCheck")
    // openSquares = document.getElementsByClassName("open-square")
    // //console.log(openSquares)
    squares.forEach(square=>{
        if(square.classList.contains("black-pawn")){
            // //console.log("found one")
            // //console.log(square)

            blackPawn(square)
            
        }
        if(square.classList.contains("black-bishop")){
            // //console.log("found one")
            // //console.log(square)

            blackBishop(square)
            
        }
        if(square.classList.contains("black-rook")){
            // //console.log("found one")
            // //console.log(square)

            blackRook(square)
            
        }
        if(square.classList.contains("black-knight")){
            // //console.log("found one")
            // //console.log(square)

            blackKnight(square)
            
        }
        if(square.classList.contains("black-queen")){
            // //console.log("found one")
            // //console.log(square)
            blackQueen(square)
        }
        if(square.classList.contains("black-king")){
            // //console.log("found one")
            // //console.log(square)

            blackKing(square)
            
        }
        // square.classList.remove("open-square")
    })
    whitePiecesToCapture()
    // document.getElementsByClassName("white-king")[0].classList.remove("check")
    // if(document.getElementsByClassName("white-king")[0].classList.contains("capturable-light")
    // ||document.getElementsByClassName("white-king")[0].classList.contains("capturable-dark")){
    //     //console.log("white king now in check")
    //     document.getElementsByClassName("white-king")[0].classList.add("check")
    // }
    
    // squares.forEach(square=>{
    //     if(square.classList.contains("capturable-light")
    //     ||square.classList.contains("capturable-dark")){
    //         //console.log(square)
    //     }
    // })


    square.classList.remove("check")
    // if(square.classList.contains("capturable-light")
    // ||square.classList.contains("capturable-dark")
    // ||square.classList.contains("open-square"))
    if(square.classList.contains("open-square")){
        // console.log("KING WOULD BE IN CHECK")
        //console.log("white king now in check")
        console.log(square)
        square.classList.add("check")
    }
    


    // //console.log(openSquares)
    //comment out to see potential moves
    squares.forEach(square=>{

        square.classList.remove("open-square")
        square.classList.remove("selecting-light")
        square.classList.remove("selecting-dark")
        square.classList.remove("capturable-light")
        square.classList.remove("capturable-dark")
        square.classList.remove("castleable-light")
        square.classList.remove("castleable-dark")
        square.removeEventListener("click",blackMoving)
    })
}

function colorKinginCheck(color,square){ //square is king's square
    let oppositeColor = setOppositeColor(color)
    clickAllColorPieces(oppositeColor)
    square.classList.remove("check")
    // if(square.classList.contains("capturable-light")
    // ||square.classList.contains("capturable-dark")
    // ||square.classList.contains("open-square"))
    if(square.classList.contains("open-square")){
        // console.log("KING WOULD BE IN CHECK")
        // console.log(square)
        //console.log("white king now in check")
        // square.classList.add("check")
        inCheck = true
    }
    else
        inCheck = false
    squares.forEach(square=>{

        square.classList.remove("open-square")
        square.classList.remove("selecting-light")
        square.classList.remove("selecting-dark")
        square.classList.remove("capturable-light")
        square.classList.remove("capturable-dark")
        square.classList.remove("castleable-light")
        square.classList.remove("castleable-dark")
        square.removeEventListener("click",movePiece)
    })
    return inCheck

    // console.log(square.classList)
    // console.log(color,"kinginCheck after")
    // openSquares = document.getElementsByClassName("open-square")
    // //console.log(openSquares)
    
    // squares.forEach(square=>{
    //     if(square.classList.contains(oppositeColor+"-pawn")){
    //         console.log("found one")
    //         // //console.log(square)

    //         clickPiece(oppositeColor,square)
            
    //     }
    // enemyPawns = document.querySelectorAll("."+oppositeColor+"-pawn")

    // enemyPawns.forEach(square=>{
    //     // console.log(square)
    //     clickPiece(oppositeColor,square)
    // })

    // enemyKnights = document.querySelectorAll("."+oppositeColor+"-knight")
    // enemyKnights.forEach(square=>{
    //     // console.log(square)
    //     clickPiece(oppositeColor,square)
    // })

    // enemyBishops = document.querySelectorAll("."+oppositeColor+"-bishop")
    // enemyBishops.forEach(square=>{
    //     // console.log(square)
    //     clickPiece(oppositeColor,square)
    // })

    // enemyRooks = document.querySelectorAll("."+oppositeColor+"-rook")
    // enemyRooks.forEach(square=>{
    //     // console.log(square)
    //     clickPiece(oppositeColor,square)
    // })

    // enemyKing = document.querySelectorAll("."+oppositeColor+"-king")
    // enemyKing.forEach(square=>{
    //     // console.log(square)
    //     clickPiece(oppositeColor,square)
    // })

    // enemyQueen = document.querySelectorAll("."+oppositeColor+"-queen")
    // enemyQueen.forEach(square=>{
    //     // console.log(square)
    //     clickPiece(oppositeColor,square)
    // })
    
        
        // if(square.classList.contains(oppositeColor+"-knight")){
        //     // //console.log("found one")
        //     // //console.log(square)

        //     clickPiece(oppositeColor,square)

            
        // }
        // if(square.classList.contains(oppositeColor+"-bishop")){
        //     // //console.log("found one")
        //     // //console.log(square)

        //     clickPiece(oppositeColor,square)

            
        // }
        // if(square.classList.contains(oppositeColor+"-rook")){
        //     // //console.log("found one")
        //     // //console.log(square)

        //     clickPiece(oppositeColor,square)

            
        // }
        // if(square.classList.contains(oppositeColor+"-king")){
        //     // //console.log("found one")
        //     // //console.log(square)
        //     clickPiece(oppositeColor,square)

        // }
        // if(square.classList.contains(oppositeColor+"-queen")){
        //     // //console.log("found one")
        //     // //console.log(square)

        //     clickPiece(oppositeColor,square)

            
        // }
        // square.classList.remove("open-square")
    // })
    // piecesToCapture(color)
    // document.getElementsByClassName("white-king")[0].classList.remove("check")
    // if(document.getElementsByClassName("white-king")[0].classList.contains("capturable-light")
    // ||document.getElementsByClassName("white-king")[0].classList.contains("capturable-dark")){
    //     //console.log("white king now in check")
    //     document.getElementsByClassName("white-king")[0].classList.add("check")
    // }
    
    // squares.forEach(square=>{
    //     if(square.classList.contains("capturable-light")
    //     ||square.classList.contains("capturable-dark")){
    //         //console.log(square)
    //     }
    // })
    
    // console.log(square.classList)


    // //console.log(openSquares)
    //comment out to see potential moves
    
}

function whiteRemoveLastPieceEventListeners(square){
    // if (whiteLastSelectedPiece==="white-pawn"){
    //     // square.addEventListener("click",whitePawn)
    //     squares[whiteLastSelectedLocation].removeEventListener("click",whitePawn)
    // }
    // else if(whiteLastSelectedPiece==="white-rook"){
    //     // square.addEventListener("click",whiteRook)
    //     squares[whiteLastSelectedLocation].removeEventListener("click",whiteRook)
    // }
    // else if(whiteLastSelectedPiece==="white-bishop"){
    //     // square.addEventListener("click",whiteBishop)
    //     squares[whiteLastSelectedLocation].removeEventListener("click",whiteBishop)
    // }
    // else if(whiteLastSelectedPiece==="white-king"){
    //     // square.addEventListener("click",whiteKing)
    //     squares[whiteLastSelectedLocation].removeEventListener("click",whiteKing)
    // }
    // else if(whiteLastSelectedPiece==="white-queen"){
    //     // square.addEventListener("click",whiteQueen)
    //     squares[whiteLastSelectedLocation].removeEventListener("click",whiteQueen)
    // }
    // else if(whiteLastSelectedPiece==="white-knight"){
    //     // square.addEventListener("click",whiteKnight)
    //     squares[whiteLastSelectedLocation].removeEventListener("click",whiteKnight)
    // }
    squares[whiteLastSelectedLocation].removeEventListener("click",whiteKnight)
    squares[whiteLastSelectedLocation].removeEventListener("click",whiteQueen)
    squares[whiteLastSelectedLocation].removeEventListener("click",whiteKing)
    squares[whiteLastSelectedLocation].removeEventListener("click",whiteBishop)
    squares[whiteLastSelectedLocation].removeEventListener("click",whiteRook)
    squares[whiteLastSelectedLocation].removeEventListener("click",whitePawn)





}
function removeLastPieceEventListeners(color){
    
    squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickPiece)
    // squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickPawn)
    // squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickKnight)
    // squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickQueen)
    // squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickKing)
    // squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickBishop)
    // squares[vars[color+"LastSelectedLocation"]].removeEventListener("click",clickRook)




}

function blackRemoveLastPieceEventListeners(square){
    // if (blackLastSelectedPiece==="black-pawn"){
    //     // square.addEventListener("click",blackPawn)
    //     squares[blackLastSelectedLocation].removeEventListener("click",blackPawn)
    // }
    // else if(blackLastSelectedPiece==="black-rook"){
    //     // square.addEventListener("click",blackRook)
    //     squares[blackLastSelectedLocation].removeEventListener("click",blackRook)
    // }
    // else if(blackLastSelectedPiece==="black-bishop"){
    //     // square.addEventListener("click",blackBishop)
    //     squares[blackLastSelectedLocation].removeEventListener("click",blackBishop)
    // }
    // else if(blackLastSelectedPiece==="black-king"){
    //     // square.addEventListener("click",blackKing)
    //     squares[blackLastSelectedLocation].removeEventListener("click",blackKing)
    // }
    // else if(blackLastSelectedPiece==="black-queen"){
    //     // square.addEventListener("click",blackQueen)
    //     squares[blackLastSelectedLocation].removeEventListener("click",blackQueen)
    // }
    // else if(blackLastSelectedPiece==="black-knight"){
    //     // square.addEventListener("click",blackKnight)
    //     squares[blackLastSelectedLocation].removeEventListener("click",blackKnight)
    // }
    console.log("removing event listeners from :")
    console.log(squares[blackLastSelectedLocation])
    squares[blackLastSelectedLocation].removeEventListener("click",blackKnight)
    squares[blackLastSelectedLocation].removeEventListener("click",blackQueen)
    squares[blackLastSelectedLocation].removeEventListener("click",blackKing)
    squares[blackLastSelectedLocation].removeEventListener("click",blackBishop)
    squares[blackLastSelectedLocation].removeEventListener("click",blackRook)
    squares[blackLastSelectedLocation].removeEventListener("click",blackPawn)





}

function addWhitePieceEventListeners(){
    
    whitePawns = document.querySelectorAll(".white-pawn")
    whitePawns.forEach(square =>{
        square.addEventListener("click",whitePawn)
    })
    whiteBishops = document.querySelectorAll(".white-bishop")
    whiteBishops.forEach(square =>{
        square.addEventListener("click",whiteBishop)
    })
    whiteKnights = document.querySelectorAll(".white-knight")
    whiteKnights.forEach(square =>{
        square.addEventListener("click",whiteKnight)
    })
    whiteRooks = document.querySelectorAll(".white-rook")
    whiteRooks.forEach(square =>{
        square.addEventListener("click",whiteRook)
    })
    whiteking = document.querySelector(".white-king")
    
    whiteking.addEventListener("click",whiteKing)
    
    whitequeen = document.querySelector(".white-queen")
    whitequeen.addEventListener("click",whiteQueen)
}


function addBlackPieceEventListeners(){
    
    blackPawns = document.querySelectorAll(".black-pawn")

    blackPawns.forEach(square =>{
        // console.log(square)
        square.addEventListener("click",blackPawn)
    })
    blackBishops = document.querySelectorAll(".black-bishop")
    blackBishops.forEach(square =>{
        square.addEventListener("click",blackBishop)
    })
    blackKnights = document.querySelectorAll(".black-knight")
    blackKnights.forEach(square =>{
        square.addEventListener("click",blackKnight)
    })
    blackRooks = document.querySelectorAll(".black-rook")
    blackRooks.forEach(square =>{
        square.addEventListener("click",blackRook)
    })
    blackking = document.querySelector(".black-king")
    
    blackking.addEventListener("click",blackKing)
    
    blackqueen = document.querySelector(".black-queen")
    blackqueen.addEventListener("click",blackQueen)
}

function addPieceEventListeners(color){
    // console.log("calling addPieceEventListeners"+color)
    // pieces = document.querySelectorAll("."+color+"-knight,."+color+"-pawn,."+color+"-bishop,."+color+"-rook,."+color+"-king,."+color+"-queen")
    pieces = document.querySelectorAll(`[piece="${color}-pawn"],[piece="${color}-bishop"],[piece="${color}-knight"],[piece="${color}-queen"],[piece="${color}-king"],[piece="${color}-rook"]`)
    // console.log(pieces)
    
    pieces.forEach(square=>{
        square.addEventListener("click",clickPiece)
    })

    // bishops = document.querySelectorAll("."+color+"-bishop")
    // bishops.forEach(square =>{
    //     square.addEventListener("click",clickBishop)
    // })
    // knights = document.querySelectorAll("."+color+"-knight")
    // knights.forEach(square =>{
    //     square.addEventListener("click",clickKnight)
    // })
    // rooks = document.querySelectorAll("."+color+"-rook")
    // whiteRooks.forEach(square =>{
    //     square.addEventListener("click",clickRook)
    // })
    // king = document.querySelector("."+color+"-king")
    
    // king.addEventListener("click",clickKing)
    
    // queen = document.querySelector("."+color+"-queen")
    // queen.addEventListener("click",clickQueen)
}


function removeWhitePieceEventListeners(){
    whitePawns = document.querySelectorAll(".white-pawn")
    whitePawns.forEach(square =>{
        square.removeEventListener("click",whitePawn)
    })
    whiteBishops = document.querySelectorAll(".white-bishop")
    whiteBishops.forEach(square =>{
        square.removeEventListener("click",whiteBishop)
    })
    whiteKnights = document.querySelectorAll(".white-knight")
    whiteKnights.forEach(square =>{
        square.removeEventListener("click",whiteKnight)
    })
    whiteRooks = document.querySelectorAll(".white-rook")
    whiteRooks.forEach(square =>{
        square.removeEventListener("click",whiteRook)
    })
    whiteking = document.querySelector(".white-king")
    
    whiteking.removeEventListener("click",whiteKing)
    
    whitequeen = document.querySelector(".white-queen")
    whitequeen.removeEventListener("click",whiteQueen)
}





function removeBlackPieceEventListeners(){
    
    blackPawns = document.querySelectorAll(".black-pawn")
    blackPawns.forEach(square =>{
        square.removeEventListener("click",blackPawn)
    })
    blackBishops = document.querySelectorAll(".black-bishop")
    blackBishops.forEach(square =>{
        square.removeEventListener("click",blackBishop)
    })
    blackKnights = document.querySelectorAll(".black-knight")
    blackKnights.forEach(square =>{
        square.removeEventListener("click",blackKnight)
    })
    blackRooks = document.querySelectorAll(".black-rook")
    blackRooks.forEach(square =>{
        square.removeEventListener("click",blackRook)
    })
    blackking = document.querySelector(".black-king")
    
    blackking.removeEventListener("click",blackKing)
    
    blackqueen = document.querySelector(".black-queen")
    blackqueen.removeEventListener("click",blackQueen)
}

function removePieceEventListeners(color){
    // document.releaseEvents("click",clickPiece)
    // pieces = document.querySelectorAll("."+color+"-pawn","."+color+"-knight")
    pieces = document.querySelectorAll("."+color+"-knight,."+color+"-pawn,."+color+"-bishop,."+color+"-rook,."+color+"-king,."+color+"-queen")

    
    pieces.forEach(square=>{
        square.removeEventListener("click",clickPiece)
    })


    // pawns = document.querySelectorAll("."+color+"+-pawn")
    // pawns.forEach(square =>{
    //     square.removeEventListener("click",clickPawn)
    // })
    // bishops = document.querySelectorAll("."+color+"+-bishop")
    // bishops.forEach(square =>{
    //     square.removeEventListener("click",clickBishop)
    // })
    // knights = document.querySelectorAll("."+color+"+-knight")
    // knights.forEach(square =>{
    //     square.removeEventListener("click",clickKnight)
    // })
    // rooks = document.querySelectorAll("."+color+"+-rook")
    // rooks.forEach(square =>{
    //     square.removeEventListener("click",clickRook)
    // })
    // king = document.querySelector("."+color+"+-king")
    
    // king.removeEventListener("click",clickKing)
    
    // queen = document.querySelector("."+color+"+-queen")
    // queen.removeEventListener("click",clickQueen)
}
    
    

function blackMovingEventListeners(square){
    if (blackLastSelectedPiece==="black-pawn"){
        square.addEventListener("click",blackPawn)
        squares[blackLastSelectedLocation].removeEventListener("click",blackPawn)
    }
    else if(blackLastSelectedPiece==="black-rook"){
        square.addEventListener("click",blackRook)
        squares[blackLastSelectedLocation].removeEventListener("click",blackRook)
    }
    else if(blackLastSelectedPiece==="black-bishop"){
        square.addEventListener("click",blackBishop)
        squares[blackLastSelectedLocation].removeEventListener("click",blackBishop)
    }
    else if(blackLastSelectedPiece==="black-king"){
        square.addEventListener("click",blackKing)
        squares[blackLastSelectedLocation].removeEventListener("click",blackKing)
    }
    else if(blackLastSelectedPiece==="black-queen"){
        square.addEventListener("click",blackQueen)
        squares[blackLastSelectedLocation].removeEventListener("click",blackQueen)
    }
    else if(blackLastSelectedPiece==="black-knight"){
        square.addEventListener("click",blackKnight)
        squares[blackLastSelectedLocation].removeEventListener("click",blackKnight)
    }
}

async function whiteMoving(){
    console.log("calling whiteMoving")
    temp = whiteLastSelectedLocation
    // square = squares[whiteLastSelectedLocation]
    // square = squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1]
    //this is the square it moves to
    let square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    whiteIsPromoting = false
    selectingPieceWhite=false
        if(square.classList.contains("black-en-passant-pawn")){
            console.log("triggered")
            square.classList.remove("black-pawn")
        }
        if(square.classList.contains("capturable-dark")||square.classList.contains("capturable-light")){
            //console.log("removes piece")
            square.classList.remove(square.classList[1])
        }
        
        // //console.log(whiteLastSelectedPiece)
        // //console.log(whiteLastSelectedLocation)
        // square.classList.add("taken")
        //castling king-side
        if(vars[color+"LastSelectedPiece"]==="white-king"&&!vars[color+"KingOrRookMoved"]&&(square===squares[62]||square===squares[63])){
            //console.log("castleing kingside")
            squaresMatrix[7][6].classList.add("white-king")
            squaresMatrix[7][5].classList.add("white-rook")
            squaresMatrix[7][7].classList.remove("white-rook")
            squaresMatrix[7][4].classList.remove("white-king")
        }
        else if(vars[color+"LastSelectedPiece"]==="white-king"&&!vars[color+"KingOrRookMoved"]&&(square===squares[57]||square===squares[56])){
            //console.log("castleing queenside")
            squaresMatrix[7][2].classList.add("white-king")
            squaresMatrix[7][3].classList.add("white-rook")
            squares[56].classList.remove("white-rook")
            squaresMatrix[7][4].classList.remove("white-king")
        }

        else{
            
            //actually adds the new piece to location that is clicked
            square.classList.add(vars[color+"LastSelectedPiece"])
            

        }
        if(whiteLastSelectedPiece==="white-king"||whiteLastSelectedPiece==="white-rook"){
            whiteKingOrRookMoved = true;
        }
        
        // squares[whiteLastSelectedLocation].classList.remove("taken")

        //actually removes the piece from its previously location
        squares[whiteLastSelectedLocation].classList.remove(whiteLastSelectedPiece)
        // square.classList.remove(check)
        // if( squares[whiteLastSelectedLocation].classList.contains(check)){
            squares[whiteLastSelectedLocation].classList.remove("check")
        // }
        squares.forEach(square =>{
            square.classList.remove("selecting-dark")        
            square.classList.remove("selecting-light")
            square.classList.remove("black-en-passant-pawn")
            if(square.classList.contains("open-square")){
                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")
                //console.log(square.classList)
                // if(square.classList[1]=="black-pawn"){
                //     square.classList.remove(square.classList[1])
                // }
                square.classList.remove("black-en-passant-pawn")
                square.classList.remove("selecting-dark")        
                square.classList.remove("castleable-dark")
                square.classList.remove("castleable-light")
            }
        });
        //en passant candidates
        if(whiteLastSelectedPiece==="white-pawn"&&whiteLastSelectedLocation-16===(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
            square.classList.add("white-en-passant-pawn")
        }
            //capturing en passant
            if(square.classList.contains("white-en-passant-square")){
            squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("black-pawn")
            squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("black-en-passant-pawn")
            // squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("capturable-light")
            // squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("capturable-dark")
            square.classList.remove("white-en-passant-square")
        }
        


        //pawn promotion
        if(whiteLastSelectedPiece==="white-pawn"&&parseInt(square.dataset.idy)===1){
            //console.log("promoting on square "+(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1))
            // square.classList.add("white-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.add("white-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.add("white-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.add("white-bishop")
            // squares[arguments[0]+8].addEventListener(pawnHighlight)
            square.classList.remove("white-pawn")
            whitePawnPromotion(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
            // await whitePromotionChooser()
            whiteIsPromoting = true
            // square.classList.remove("white-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.remove("white-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.remove("white-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.remove("white-bishop")
        }
        // whiteMovingEventListeners(square)
        whiteIsPromoting = false
        whiteLastSelectedLocation = temp
        // addWhitePieceEventListeners()
        whiteRemoveLastPieceEventListeners()
        if (!whiteIsPromoting){
            switchTurn()
            
            // squares.forEach(square =>{
            //     square.addEventListener("click",blackClickBox)
            //     square.removeEventListener("click",whiteClickBox)
            // })

            
            console.log("checking to see if black king is mated")

            //enemy now in check?
            

            isBlackKinginCheck(document.getElementsByClassName("black-king")[0])
            if(document.getElementsByClassName("black-king")[0].classList.contains("check")){
                didBlackGetMated()
            }

            if(whiteLastSelectedPiece=="white-king"){
                squares[whiteLastSelectedLocation].classList.remove("check")
            }
            else{
                document.getElementsByClassName("white-king")[0].classList.remove("check")
            }
        }
        
        

        

        
        
        
}

function clearAttacked(){
    attackedSquares = document.querySelectorAll(".attacked")
    // console.log(pinnedPieces)
    // whiteEnPawn = document.getElementsByClassName("white-en-passant-pawn")[0]
    
    if(attackedSquares.length>0){
        // console.log(typeof pinnedPieces)
        attackedSquares.forEach(square=>{
            square.classList.remove("attacked")
        })
    }
}

function clearPinned(){
    pinnedPieces = document.querySelectorAll(".pinned")
    // console.log(pinnedPieces)
    // whiteEnPawn = document.getElementsByClassName("white-en-passant-pawn")[0]
    
    if(pinnedPieces.length>0){
        // console.log(typeof pinnedPieces)
        pinnedPieces.forEach(piece=>{
            piece.classList.remove("pinned")
        })
    }
}

async function movePiece(color,square){
    // console.log("calling movePiece")
    clearPinned()
    clearAttacked()
    if (color.target!=undefined){
        console.log("manual move")

        color = this.pieceColor
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
        // removeWhiteSelections()
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
        idx = square.dataset.idx
        idy = square.dataset.idy
    }
    // else{
    //     console.log("AI move")
    // }
    oppositeColor = setOppositeColor(color)
    // console.log("calling movePiece")
    temp = vars[color+"LastSelectedLocation"]
    // console.log(temp)
    // square = squares[whiteLastSelectedLocation]
    // square = squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1]
    //this is the square it moves to
    // let square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    // whiteIsPromoting = false
    // selectingPieceWhite=false
        if(square.classList.contains(oppositeColor+"-en-passant-pawn")){
            console.log("triggered")
            // square.classList.remove(oppositeColor+"-pawn")
            square.classList.remove(oppositeColor+"-en-passant-pawn")
        }
        if(square.classList.contains("capturable-dark")||square.classList.contains("capturable-light")||vars[oppositeColor+"Pieces"].includes(square.classList[1])){
            //console.log("removes piece")
            square.classList.remove(square.classList[1])
        }
        // if(squares[vars[color+"LastSelectedLocation"]].classList.contains())
        
        // //console.log(whiteLastSelectedPiece)
        // //console.log(whiteLastSelectedLocation)
        // square.classList.add("taken")
     
        if(vars[color+"LastSelectedPiece"]=="white-king"&&vars[color+"CastleableKS"]&&(square===squares[62]||square===squares[63])){

            //console.log("castleing kingside")
            squaresMatrix[7][6].classList.add("white-king")
            squaresMatrix[7][5].classList.add("white-rook")
            squaresMatrix[7][7].classList.remove("white-rook")
            squaresMatrix[7][4].classList.remove("white-king")
        }
        else if(vars[color+"LastSelectedPiece"]=="white-king"&&vars[color+"CastleableQS"]&&(square===squares[57]||square===squares[56])){
            //console.log("castleing queenside")
            squaresMatrix[7][2].classList.add("white-king")
            squaresMatrix[7][3].classList.add("white-rook")
            squares[56].classList.remove("white-rook")
            squaresMatrix[7][4].classList.remove("white-king")
        }
        if(vars[color+"LastSelectedPiece"]=="black-king"&&vars[color+"CastleableKS"]&&(square===squaresMatrix[0][6]||square===squaresMatrix[0][7])){
            //console.log("castleing kingside")
            squaresMatrix[0][6].classList.add("black-king")
            squaresMatrix[0][5].classList.add("black-rook")
            squaresMatrix[0][7].classList.remove("black-rook")
            squaresMatrix[0][4].classList.remove("black-king")
        }
        else if(vars[color+"LastSelectedPiece"]=="black-king"&&vars[color+"CastleableQS"]&&(square===squaresMatrix[0][2]||square===squaresMatrix[0][0])){
            //console.log("castleing queenside")
            squaresMatrix[0][2].classList.add("black-king")
            squaresMatrix[0][3].classList.add("black-rook")
            squaresMatrix[0][0].classList.remove("black-rook")
            squaresMatrix[0][4].classList.remove("black-king")
        }
        else{
            //actually adds the new piece to location that is clicked
            square.classList.add(vars[color+"LastSelectedPiece"])
        }
        if(color=="white"){
            if(vars[color+"LastSelectedPiece"]==color+"-king"||vars[color+"LastSelectedLocation"]==56){
                console.log(color,"can no longer castle QS")
                vars[color+"CastleableQS"] = false;
            }
            if(vars[color+"LastSelectedPiece"]==color+"-king"||vars[color+"LastSelectedLocation"]==63){
                console.log(color,"can no longer castle KS")
                vars[color+"CastleableKS"] = false;
            }
        }
        else{
            if(vars[color+"LastSelectedPiece"]==color+"-king"||vars[color+"LastSelectedLocation"]==0){
                console.log(color,"can no longer castle QS")
                vars[color+"CastleableQS"] = false;
            }
            if(vars[color+"LastSelectedPiece"]==color+"-king"||vars[color+"LastSelectedLocation"]==7){
                console.log(color,"can no longer castle KS")
                vars[color+"CastleableKS"] = false;
            }
        }
        
        
        
        //actually removes the piece from its previously location
        // squares[vars[color+"LastSelectedLocation"]].classList.remove(vars[color+"LastSelectedPiece"])
        // console.log(squares[vars[color+"LastSelectedLocation"]].classList)
        let currentPiece = squares[vars[color+"LastSelectedLocation"]].classList[1]
        // console.log(currentPiece)
        squares[vars[color+"LastSelectedLocation"]].classList.remove(currentPiece)

        // square.classList.remove(check)
        // if( squares[whiteLastSelectedLocation].classList.contains(check)){
        // squares[vars[color+"LastSelectedLocation"]].classList.remove("check")
        // }
        squares.forEach(square =>{
            square.classList.remove("selecting-dark")        
            square.classList.remove("selecting-light")
            square.classList.remove("black-en-passant-pawn")
            if(square.classList.contains("open-square")){
                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")
                //console.log(square.classList)
                // if(square.classList[1]=="black-pawn"){
                //     square.classList.remove(square.classList[1])
                // }
                square.classList.remove(color+"-en-passant-pawn")
                square.classList.remove("selecting-dark")        
                square.classList.remove("castleable-dark")
                square.classList.remove("castleable-light")
            }
        });
        // console.log("before:",square.classList)
        //en passant candidates
        clearEnPassant("white")
        clearEnPassant("black")
        if(vars[color+"LastSelectedPiece"]=="white-pawn"&&vars[color+"LastSelectedLocation"]-16===(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
            square.classList.add("white-en-passant-pawn")
            // console.log("adding en passant")
            // console.log(square.classList)
        }
        
        else if(vars[color+"LastSelectedPiece"]=="black-pawn"&&vars[color+"LastSelectedLocation"]+16===(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
            square.classList.add("black-en-passant-pawn")
            // console.log(square.classList)
        }
        
            //capturing en passant
        if(square.classList.contains("white-en-passant-square")){
            squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("black-pawn")
            squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("black-en-passant-pawn")
            // squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("capturable-light")
            // squares[8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1].classList.remove("capturable-dark")
            square.classList.remove("white-en-passant-square")
        }
        else if(square.classList.contains("black-en-passant-square")){
            squares[8*(parseInt(square.dataset.idy)-1-1)+parseInt(square.dataset.idx)-1].classList.remove("white-pawn")
            squares[8*(parseInt(square.dataset.idy)-1-1)+parseInt(square.dataset.idx)-1].classList.remove("white-en-passant-pawn")
            //these 3 lines cause error because of this not being square. dont think they are necessary tho
            // squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("white-en-passant-pawn")
            // squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("capturable-light")
            // squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("capturable-dark")
            square.classList.remove("black-en-passant-square")
        }
        
        

        //pawn promotion
        if(vars[color+"LastSelectedPiece"]==="white-pawn"&&parseInt(square.dataset.idy)===1){
            //console.log("promoting on square "+(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1))
            // square.classList.add("white-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.add("white-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.add("white-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.add("white-bishop")
            // squares[arguments[0]+8].addEventListener(pawnHighlight)
            square.classList.remove("white-pawn")
            whitePawnPromotion(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
            // await whitePromotionChooser()
            // whiteIsPromoting = true
            // square.classList.remove("white-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.remove("white-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.remove("white-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.remove("white-bishop")
        }
        else if(vars[color+"LastSelectedPiece"]==="black-pawn"&&parseInt(square.dataset.idy)===8){
            //console.log("promoting on square "+(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1))
            // square.classList.add("black-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.add("black-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.add("black-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.add("black-bishop")
            // squares[arguments[0]+8].addEventListener(pawnHighlight)
            square.classList.remove("black-pawn")
            blackPawnPromotion(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
            // await blackPromotionChooser()
            //console.log("done promoting")
            // square.classList.remove("black-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.remove("black-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.remove("black-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.remove("black-bishop")
        }
        else{
            switchTurn()
        }
        // whiteMovingEventListeners(square)
        // whiteIsPromoting = false
        vars[color+"LastSelectedLocation"] = temp
        
        // addWhitePieceEventListeners()
        removeLastPieceEventListeners(color)

        
        // squares.forEach(square =>{
        //     square.addEventListener("click",blackClickBox)
        //     square.removeEventListener("click",whiteClickBox)
        // })

        
        // console.log("checking to see if",oppositeColor,"king is mated")

        //enemy now in check?
        
        clickAllColorPieces(color)
        // if(colorKinginCheck(oppositeColor,document.getElementsByClassName(oppositeColor+"-king")[0])){
            // document.getElementsByClassName(oppositeColor+"-king")[0].classList.add("check")
            // didColorGetMated2(oppositeColor)
            
        // }
        // console.log(document.querySelector(color+"-king"))
        document.getElementsByClassName(color+"-king")[0].classList.remove("check")

        //     // didColorGetMated(oppositeColor)

        // if(whiteLastSelectedPiece=="white-king"){
        //     squares[whiteLastSelectedLocation].classList.remove("check")
        // }
        // else{
        //     document.getElementsByClassName("white-king")[0].classList.remove("check")
        // }
    // console.log(evaluate())
    evaluate()
}
                
function clearEnPassant(color){
    enPawn = document.getElementsByClassName(color+"-en-passant-pawn")[0]
    // whiteEnPawn = document.getElementsByClassName("white-en-passant-pawn")[0]
    if(typeof enPawn != "undefined"){
        // console.log(whiteEnPawn)
        enPawn.classList.remove(color+"-en-passant-pawn")
    }
}





function whiteSelectingPiece(){
    let square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
}



function removeWhiteSelections(){
    console.log("calling removeWhiteSelections")
    squares.forEach(square =>{
            square.classList.remove("selecting-dark")        
            square.classList.remove("selecting-light")
            square.removeEventListener("click",whiteMoving)

                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")

                square.classList.remove("white-en-passant-square")
            if(square.classList.contains("open-square")){
                console.log(square)
                square.removeEventListener("click",whiteMoving)

                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")

                square.classList.remove("white-en-passant-square")
            }square.classList.remove("white-en-passant-pawn")
            
    })
}

function removeBlackSelections(){
    squares.forEach(square =>{
        square.removeEventListener("click",blackMoving)
            square.classList.remove("selecting-dark")        
            square.classList.remove("selecting-light")
            square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")

            if(square.classList.contains("open-square")){
                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")

                square.classList.remove("black-en-passant-square")
            }square.classList.remove("black-en-passant-pawn")
    })
}

function removeSelections(color){
    console.log("calling removeWhiteSelections",color)
    squares.forEach(square =>{
            square.classList.remove("selecting-dark")        
            square.classList.remove("selecting-light")
            square.removeEventListener("click",window[color+"Moving"])

                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")

                square.classList.remove(color+"-en-passant-square")
            if(square.classList.contains("open-square")){
                console.log(square)
                square.removeEventListener("click",window[color+"Moving"])
                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")

                square.classList.remove(color+"-en-passant-square")
            }square.classList.remove(color+"-en-passant-pawn")
    })
}


function doesMoveHangWhiteKing(isKinginCheck){
    console.log("calling doesMoveHangWhiteKing")
    console.log(vars[color+"LastSelectedPiece"])
    kingInCheck = isKinginCheck
    //console.log("starting code to limit moves")
    var openSquares = document.getElementsByClassName("open-square")
    const movesToCheck = []
    
    for(let square of openSquares){
        // //console.log(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
        movesToCheck.push(squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1])
    }
    movesToCheck.forEach(square =>{
        console.log(square)
    })

    movesToCheck.forEach(square =>{
        tempPieceHolder = false
        movesToCheck.forEach(square =>{
            square.classList.remove("open-square")
        })
        //if the first move evaluated stops check but the next dont, it doesnt work

        //console.log("moving to ",8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
        // console.log(whiteLastSelectedPiece)
        // console.log(whiteLastSelectedLocation)
        console.log(whiteLastSelectedPiece)
        square.classList.add(whiteLastSelectedPiece)
        squares[whiteLastSelectedLocation].classList.remove(whiteLastSelectedPiece)

        if(blackPieces.includes(square.classList[1])){//if we are capturing a piece
            tempPiece = square.classList[1]
            tempPieceHolder = true
            square.classList.remove(square.classList[1])
            // if(square.classList.contains(""))
            // square.classList.add("capturable-light")
        }
        // wait(7000);
        //console.log(square)
        if(whiteLastSelectedPiece=="white-king"){
            isWhiteKinginCheck(square)
            if(!square.classList.contains("check")){
                square.classList.add("open-square-that-stops-check") 
                //console.log("would bring king out of check")
            }
            //console.log("dealing with king")
            square.classList.remove("check")
            
        }

        //base case, we ask to see if the white king would be in check after the move
        else{
            isWhiteKinginCheck(document.getElementsByClassName("white-king")[0])

            if(!document.getElementsByClassName("white-king")[0].classList.contains("check")){
                square.classList.add("open-square-that-stops-check")
            // throw new Error("stop!");
            }
        }
        //putting the pieces back
        if(tempPieceHolder){

            square.classList.add(tempPiece)
            // if(square.classList.contains(""))
            // square.classList.add("capturable-light")
        }
        square.classList.remove(whiteLastSelectedPiece)
        squares[whiteLastSelectedLocation].classList.add(whiteLastSelectedPiece)
        if(isKinginCheck){
            document.getElementsByClassName("white-king")[0].classList.add("check")
        }
        else{
            document.getElementsByClassName("white-king")[0].classList.remove("check")
        }
    })
    //console.log("done limiting moves")
    
    for(let square of movesToCheck){
        if(square.classList.contains("open-square-that-stops-check")){
            square.classList.remove("open-square-that-stops-check")
            square.classList.add("open-square")
            // console.log(square)
        }
        else{
            square.removeEventListener("mouseover",whiteHighlight)
            square.removeEventListener("mouseout",whiteUnhighlight)

        }
    }

    if(whiteLastSelectedPiece=="white-king"){
        //console.log(" king")
    }
    else{
    //console.log("not king")
        squaresMatrix[7][7].classList.remove("castleable-dark")
        squares[56].classList.remove("castleable-light")
    }
        
    // }
    // blackPiecesToCapture()
}




function doesMoveHangColorKing2(color,move){
    console.log("calling doesMoveHang...2")
    let oppositeColor = setOppositeColor(color)


    //whatever open squares are leftover from the startal piece
    //that was clicked, lets erase.
    let openSquares = document.querySelectorAll(".open-square")
    openSquares.forEach(square=>{
        square.classList.remove("open-square")
    })
 
    var tempHolder = false
    var temp2Holder = false
    var temp = ""
    var temp2 = ""
    move.start.classList.remove(move.piece)
    if(vars[oppositeColor+"Pieces"].includes(move.target.classList[1])){
        tempHolder = true
        // console.log("while checking for hangking, capturing",move.target)
        // console.log("removing",move.target.classList[1])
        temp = move.target.classList[1]
        move.target.classList.remove(temp)
        if(move.target.classList[1]==oppositeColor+"-en-passant-pawn"){
            temp2Holder = true
            temp2 = move.target.classList[1]
            move.target.classList.remove(temp2)
        }
        
        // console.log("new:",move.target.classList)
    }
    move.target.classList.add(move.piece)



    //we have now simulated the move.
    //Time to see if the king could be captured by an enemy piece
    clickAllColorPieces(oppositeColor)
    // console.log(tes)
    // console.log(brea)

    king = document.getElementsByClassName([color+"-king"])[0]
    king.classList.remove("check")
    if(king.classList.contains("open-square")){
        inCheck = true
    }
    else
        inCheck = false
    squares.forEach(square=>{
        square.classList.remove("open-square")
        square.classList.remove("selecting-light")
        square.classList.remove("selecting-dark")
        square.classList.remove("capturable-light")
        square.classList.remove("capturable-dark")
        square.classList.remove("castleable-light")
        square.classList.remove("castleable-dark")
        square.removeEventListener("click",movePiece)
    })
    
    //we got our answer. Time to return the pieces to before the move
    
    if(tempHolder){
        move.target.classList.add(temp)
        // console.log("now put back",move.target)
        if(temp2Holder)
            move.target.classList.add(temp2)
    }
    move.target.classList.remove(move.piece)
    move.start.classList.add(move.piece)
    
    
    return inCheck
}


function doesMoveHangColorKing3(color,move){
    // console.log("doesMoveHang... called with",move)
    if(document.getElementsByClassName(color+"-king")[0].classList.contains("check")){
        console.log("my king is in check")
        // if(move.target.idx==)
        if(piecesAttackingKing.length>1){
            if(move.piece!=color+"-king"){
                return true
            }
            else if(move.target.classList.contains("attacked")){
                return true
            }   
        }
        else{//if we aren't in double check, we simulate move and then click on the piece that caused check, 
            if(move.target.idx==piecesAttackingKing[0].idx&&move.target.idy==piecesAttackingKing[0].idy){
                return false
            }
            var tempClasslist = move.start.classList
            move.start.classList.remove(move.start.classList)
            move.target.classList.add(move.piece)
        }
    }
    else{

    }
    if(move.piece==color+"-king"){
        if(move.target.classList.contains("attacked")){
            return true
        }
        return false
    }
    if(move.start.classList.contains("pinned")){
        return true
    }
    return false
}
    





function doesMoveHangColorKing(color){
    let oppositeColor = setOppositeColor(color)
    // console.log("calling doesMoveHang"+color+"King")
    isKinginCheckatBeginning = document.getElementsByClassName(color+"-king")[0].classList.contains("check")
    //console.log("starting code to limit moves")
    var openSquares = document.getElementsByClassName("open-square")
    const movesToCheck = []
    
    for(let square of openSquares){
        // //console.log(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
        movesToCheck.push(squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1])
    }
    movesToCheck.forEach(square =>{
        // console.log(square)
    })

    movesToCheck.forEach(square =>{
        var tempPieceHolder = false
        var tempPiece = ""
        movesToCheck.forEach(square =>{
            square.classList.remove("open-square")
        })
        //if the first move evaluated stops check but the next dont, it doesnt work

        //console.log("moving to ",8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
        // console.log(whiteLastSelectedPiece)
        // console.log(whiteLastSelectedLocation)

        //simulates moving the piece
        enPassant = false
        // piece = vars[color+"LastSelectedPiece"]
        // console.log(piece)
        square.classList.add(vars[color+"LastSelectedPiece"])
        squares[vars[color+"LastSelectedLocation"]].classList.remove(vars[color+"LastSelectedPiece"])

        if (color == "white")
            oppositeColor = "black"
        else   
            oppositeColor = "white"
        // setOppositeColor(asdf)
        // console.log(square)
        // console.log(vars[oppositeColor+"Pieces"])
        if(vars[oppositeColor+"Pieces"].includes(square.classList[1])){//if we are capturing a piece
            // console.log("NO NO NO")
            tempPiece = square.classList[1]
            if(square.classList[2]==oppositeColor+"-en-passant-pawn"){
                enPassant = square.classList[2]
                square.classList.remove(square.classList[2])
                enPassant = true
            }
            tempPieceHolder = true
            square.classList.remove(square.classList[1])
            // console.log(square.classList)
            // if(square.classList.contains(""))
            // square.classList.add("capturable-light")
        }
        // wait(7000);
        //console.log(square)
        // if(vars[color+"LastSelectedPiece"]==vars[color+"-king"]){
        //     console.log("this doesn make sense")
        //     kinginCheck(color,square)
        //     if(!square.classList.contains("check")){
        //         square.classList.add("open-square-that-stops-check") 
        //         //console.log("would bring king out of check")
        //     }
        //     //console.log("dealing with king")
        //     square.classList.remove("check")
            
        // }

        //base case, we ask to see if the white king would be in check after the move
        // else{
            // console.log("about to call")
        colorKinginCheck(color,document.getElementsByClassName(color+"-king")[0])
        
        if(colorKinginCheck(color,document.getElementsByClassName(color+"-king")[0])){
            // console.log("SETTING KING IN CHECK TO TRUE")
            kingInCheck = true
        // throw new Error("stop!");
        }
        else
            kingInCheck = false
        
        // }
        //putting the pieces back 
        if(tempPieceHolder){
            // console.log("time to put captured piece baack")
            // console.log(square)
            // console.log(tempPiece)
            square.classList.add(tempPiece)
            // console.log(square.classList)
            if(enPassant)
                square.classList.add(oppositeColor+"-en-passant-pawn")
            // console.log(square.classList)
            // if(square.classList.contains(""))
            // square.classList.add("capturable-light")
        }
        // console.log("time to put piece back")
        // console.log("removing",vars[color+"LastSelectedPiece"],"from",square)
        
        square.classList.remove(vars[color+"LastSelectedPiece"])

        // console.log("adding",vars[color+"LastSelectedPiece"],"to",squares[vars[color+"LastSelectedLocation"]])
        squares[vars[color+"LastSelectedLocation"]].classList.add(vars[color+"LastSelectedPiece"])
        if(!kingInCheck){
            square.classList.add("open-square-that-stops-check")
        }
        kingInCheck = false
        document.getElementsByClassName(color+"-king")[0].classList.remove("check")
        // if(!document.getElementsByClassName(color+"-king")[0].classList.contains("check")){
        // throw new Error("stop!");
        // }
    })
    //console.log("done limiting moves")
    
    for(let square of movesToCheck){
        if(square.classList.contains("open-square-that-stops-check")){
            square.classList.remove("open-square-that-stops-check")
            square.classList.add("open-square")
            // console.log(square)
        }
        else{
            square.removeEventListener("mouseover",whiteHighlight)
            square.removeEventListener("mouseout",whiteUnhighlight)

        }
    }

    if(vars[color+"LastSelectedPiece"]==color+"-king"){
        //console.log(" king")
    }
    else{
    //console.log("not king")
        squaresMatrix[7][7].classList.remove("castleable-dark")
        squares[56].classList.remove("castleable-light")
        squaresMatrix[0][0].classList.remove("castleable-dark")
        squaresMatrix[0][7].classList.remove("castleable-white")
    }
        
    // }
    // blackPiecesToCapture()
    if(isKinginCheckatBeginning){
        console.log("putting",color,"king back into check")
        // console.log(document.getElementsByClassName(color+"-king")[0])
        document.getElementsByClassName(color+"-king")[0].classList.add("check")
    }
}

//can be optimized
function clearPrevious(){
    squares.forEach(square =>{
        square.classList.remove("open-square")
        square.classList.remove("selecting-dark")        
        square.classList.remove("selecting-light")
        square.removeEventListener("click",whiteMoving)
        square.removeEventListener("click",blackMoving)
        square.removeEventListener("click",movePiece)
            if(square.classList.contains("open-square")){
                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")
                
            }
    })
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////        
////////////////////////////////////////////////////////////////////////////////


function addWhiteEventListenersToOpenSquares(){
    openSquares =document.querySelectorAll('.open-square')
    // openSquares[0].addEventListener("click",whiteMoving(openSquares[0]))

    openSquares.forEach(square =>{
        square.addEventListener("click",whiteMoving)
    })
    if (squares[63].classList.contains("castleable-light")){
        squares[63].addEventListener("click",whiteMoving)
        squares[63].removeEventListener("click",whiteRook)
    }
    if (squares[56].classList.contains("castleable-dark")){
        squares[56].addEventListener("click",whiteMoving)
        squares[56].removeEventListener("click",whiteRook)
    }

}

function addEventListenersToOpenSquares(color){
    console.log("calling addEventListener to open-squares")

    openSquares =document.querySelectorAll('open-square')
    // openSquares[0].addEventListener("click",whiteMoving(openSquares[0]))
    // console.log("calling movePiece next line")
    openSquares.forEach(square =>{
        // square.pieceColor = color
        square.addEventListener("click",movePiece)
    })
    //     if(color=="white"){
    //         if (squares[63].classList.contains("castleable-light")){
    //         squares[63].addEventListener("click",whiteMoving)
    //         squares[63].removeEventListener("click",whiteRook)
    //     }
    //     if (squares[56].classList.contains("castleable-dark")){
    //         squares[56].addEventListener("click",whiteMoving)
    //         squares[56].removeEventListener("click",whiteRook)
    //     }
    // }
    // else{
    //     if (squares[0].classList.contains("castleable-light")){
    //         squares[0].addEventListener("click",blackMoving)
    //         squares[0].removeEventListener("click",blackRook)
    //     }
    //     if (squares[7].classList.contains("castleable-dark")){
    //         squares[7].addEventListener("click",blackMoving)
    //         squares[7].removeEventListener("click",blackRook)
    //     }
    // }
    

}

function addWhiteEventListenersToCapturables(){
    capturableDarks =document.querySelectorAll('.capturable-dark')
    capturableLights =document.querySelectorAll('.capturable-light')
    // openSquares[0].addEventListener("click",whiteMoving(openSquares[0]))
    capturableDarks.forEach(square =>{
        square.addEventListener("click",whiteMoving)
    })
    capturableLights.forEach(square =>{
        // square.removeEventListener("click",blackPawn)
        square.addEventListener("click",whiteMoving)
    })
    

}
//is this whole function redudant if we already add the event listeners to open squares?
function addEventListenersToCapturables(){
    capturableDarks =document.querySelectorAll('.capturable-dark')
    capturableLights =document.querySelectorAll('.capturable-light')
    // openSquares[0].addEventListener("click",whiteMoving(openSquares[0]))
    capturableDarks.forEach(square =>{
        square.addEventListener("click",movePiece)
    })
    capturableLights.forEach(square =>{
        // square.removeEventListener("click",blackPawn)
        square.addEventListener("click",movePiece)
    })
    

}



function addBlackEventListenersToOpenSquares(){
    openSquares =document.querySelectorAll('.open-square')
    // openSquares[0].addEventListener("click",blackMoving(openSquares[0]))

    openSquares.forEach(square =>{
        square.addEventListener("click",blackMoving)
    })
    if (squares[0].classList.contains("castleable-light")){
        squares[0].addEventListener("click",blackMoving)
        squares[0].removeEventListener("click",blackRook)
    }
    if (squares[7].classList.contains("castleable-dark")){
        squares[7].addEventListener("click",blackMoving)
        squares[7].removeEventListener("click",blackRook)
    }

}
function addBlackEventListenersToCapturables(){
    capturableDarks =document.querySelectorAll('.capturable-dark')
    capturableLights =document.querySelectorAll('.capturable-light')
    // openSquares[0].addEventListener("click",blackMoving(openSquares[0]))
    capturableDarks.forEach(square =>{
        square.addEventListener("click",blackMoving)
    })
    capturableLights.forEach(square =>{
        // square.removeEventListener("click",blackPawn)
        square.addEventListener("click",blackMoving)
    })
    

}

function  highlightCurrentSquare(square){
    if(square.classList.contains("blackSquare")){
        square.classList.add("selecting-dark")
    }
    else{
        square.classList.add("selecting-light")
    }
}





//using the argument is only necessary for isblackkingincheck
function whitePawn(square){
    notChecking = false
    console.log("calling whitePawn")
    // pawns =document.querySelectorAll('.white-pawn')
    // this occurs when square has not been defined
    //this happens when it is clicked, not when checking for checks
    if (square.target!=undefined){
        notChecking = true
        clearPrevious()
        removeWhiteSelections()
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
        idx = square.dataset.idx
        idy = square.dataset.idy
    }
    if(!allPieces.includes(squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-8].classList[1])){
        squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-8].classList.add("open-square")
        if(parseInt(idy)===7&&!allPieces.includes(squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-16].classList[1])){
            squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-16].classList.add("open-square")
        }
    }
        

    //up to the right
    if(parseInt(idy)-1-1>-1&&parseInt(idy)-1-1<8
    &&parseInt(idx)-1+1>-1&&parseInt(idx)-1+1<8){
        tempSquare = squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)]
        if(blackPieces.includes(tempSquare.classList[1])){
            tempSquare.classList.add("open-square")
            
        }
    }
    
    //up to the left
    if(parseInt(idy)-1-1>-1&&parseInt(idy)-1-1<8
    &&parseInt(idx)-1-1>-1&&parseInt(idx)-1-1<8){
        tempSquare = squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)]
        if(blackPieces.includes(tempSquare.classList[1])){
            tempSquare.classList.add("open-square")
            
        }
    }
        //en passant left
        if(parseInt(idy)-1>-1&&parseInt(idy)-1<8
    &&parseInt(idx)-1-1>-1&&parseInt(idx)-1-1<8){
        tempSquare = squares[(8*(parseInt(idy)-1)+parseInt(idx)-1-1)]
        if(tempSquare.classList.contains("black-en-passant-pawn")){
            squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)].classList.add("open-square")
            squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)].classList.add("white-en-passant-square")
            

        }
    }
    //en passant right
    if(parseInt(idy)-1>-1&&parseInt(idy)-1<8
    &&parseInt(idx)-1+1>-1&&parseInt(idx)-1+1<8){
        tempSquare = squares[(8*(parseInt(idy)-1)+parseInt(idx)-1+1)]
        if(tempSquare.classList.contains("black-en-passant-pawn")){
            squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)].classList.add("open-square")
            squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)].classList.add("white-en-passant-square")
        }
    }
    
    
    blackPiecesToCapture()
    whiteLastSelectedPiece =  square.classList[1]
    
    
    whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
    if(notChecking)
        doesMoveHangWhiteKing(false)
    addWhiteEventListenersToOpenSquares()
    addWhiteEventListenersToCapturables()
    highlightCurrentSquare(square)
}

function clickPiece(color,square){
    // score = evaluate()
    // console.log(score)
    notChecking = false
    // pawns =document.querySelectorAll('.white-pawn')
    // this occurs when square has not been defined
    //this happens when it is clicked, not when checking for checks
    if (color.target!=undefined){
        // console.log(this)
        color = this.getAttribute("piece").substring(0,5)
        piece = this.getAttribute("piece")
        // console.log(piece)
        notChecking = true
        clearPrevious()
        // removeWhiteSelections()
        removeSelections(color)
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
        console.log("calling clickPiece",square)
    }
    // console.log(square)
    idx = square.dataset.idx
    idy = square.dataset.idy
    // console.log(idy)
    // let piece = square.classList[1] //slice off the color
    
    //highlights certain squares depending on the piece
    // console.log(piece+"Movement")
    window[piece.slice(6)+"Movement"](color,square)
    let openSquares = document.querySelectorAll(".open-square")
    // let candidates = []
    legalMoves = []
    //the doesMoveHangKing function clears open squares each time it runs
    //therefore, we need to hold onto the legal moves in a separate 
    //variable and then add the open square class after
    openSquares.forEach(target=>{
        candidate =  {piece:piece,start:square,target:target}
        if(!doesMoveHangColorKing2(color,candidate)){
            legalMoves.push(target)
            // console.log(asdf)
            
        }
        
    })
    legalMoves.forEach(target=>{
        target.classList.add("open-square")
    })
    
    
    
    // console.log(color,"lastselectedlocation = ",squares[vars[color+"LastSelectedLocation"]])
    if(notChecking){
        vars[color+"LastSelectedPiece"] = square.classList[1]
        vars[color+"LastSelectedLocation"] = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
        // doesMoveHangColorKing(color)
        piecesToCapture(color)
        addEventListenersToOpenSquares(color)
        addEventListenersToCapturables(color)
        // console.log("asdfasdf")
        highlightCurrentSquare(square)
    }
    // else{
    //     openSquares = document.querySelectorAll(".open-square")
    //     let moves = []
    //     openSquares.forEach(target=>{
    //         moves.push({piece:piece,start:square,target:target})
    //         // target.classList.remove("open-square")
    //     })
    //     console.log(moves)
    // }

    

}

function pawnMovement(color,square){
    console.log("calling pawnMovement")
    console.log(idy)
    console.log(idx)
    // console.log(color)
    let oppositeColor = setOppositeColor(color)
    // console.log(color,square)
    //one and two up
    if(color=="white"){
        //WHITE PAWN
        // console.log(allPieces)
        // console.log(squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-8])
        if(!allPieces.includes(squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-8].classList[1])){
                console.log(squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-8])
                squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-8].setAttribute("opensquare","test")
                console.log(asf)
                if(parseInt(idy)===7&&!allPieces.includes(squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-16].classList[1])){
                    squares[(8*(parseInt(idy)-1)+parseInt(idx)-1)-16].setAttribute("open-square",true)
                }
            }
            

        //up to the right
        if(parseInt(idy)-1-1>-1&&parseInt(idy)-1-1<8
        &&parseInt(idx)-1+1>-1&&parseInt(idx)-1+1<8){
            tempSquare = squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)]
            squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)].classList.add("attacked")
        
            // console.log(blackPieces.includes(tempSquare.classList[1]))
            if(blackPieces.includes(tempSquare.classList[1])){
                tempSquare.classList.add("open-square")
                
            }
        }
       
        //up to the left
        if(parseInt(idy)-1-1>-1&&parseInt(idy)-1-1<8
        &&parseInt(idx)-1-1>-1&&parseInt(idx)-1-1<8){
            tempSquare = squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)]
            squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)].classList.add("attacked")

            if(blackPieces.includes(tempSquare.classList[1])){
                tempSquare.classList.add("open-square")
                
            }
        }
            //en passant left
            if(parseInt(idy)-1>-1&&parseInt(idy)-1<8
        &&parseInt(idx)-1-1>-1&&parseInt(idx)-1-1<8){
            tempSquare = squares[(8*(parseInt(idy)-1)+parseInt(idx)-1-1)]
            if(tempSquare.classList.contains("black-en-passant-pawn")){
                squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)].classList.add("open-square")
                squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1-1)].classList.add("white-en-passant-square")
                

            }
        }
        //en passant right
        if(parseInt(idy)-1>-1&&parseInt(idy)-1<8
        &&parseInt(idx)-1+1>-1&&parseInt(idx)-1+1<8){
            tempSquare = squares[(8*(parseInt(idy)-1)+parseInt(idx)-1+1)]
            if(tempSquare.classList.contains("black-en-passant-pawn")){
                squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)].classList.add("open-square")
                squares[(8*(parseInt(idy)-1-1)+parseInt(idx)-1+1)].classList.add("white-en-passant-square")
            }
        }
    }
        
        ////////BLACK PAWN
    else{
        if(!allPieces.includes(squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)+8].classList[1])){
    // //console.log(squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)+8])
        squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)+8].classList.add("open-square")
        if(parseInt(square.dataset.idy)===2&&!allPieces.includes(squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)+16].classList[1])){
            squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)+16].classList.add("open-square")
        }
        }
        //up to the right
        // //console.log(parseInt(square.dataset.idy)-1)
        if(parseInt(square.dataset.idy)-1+1>-1&&parseInt(square.dataset.idy)-1+1<8
        &&parseInt(square.dataset.idx)-1+1>-1&&parseInt(square.dataset.idx)-1+1<8){
            tempSquare = squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1+1)]
            squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1+1)].classList.add("attacked")
            if(whitePieces.includes(tempSquare.classList[1])){
                tempSquare.classList.add("open-square")
            }
        }
        
        //up to the left
        if(parseInt(square.dataset.idy)-1+1>-1&&parseInt(square.dataset.idy)-1+1<8
        &&parseInt(square.dataset.idx)-1-1>-1&&parseInt(square.dataset.idx)-1-1<8){
            tempSquare = squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1-1)]
            squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1-1)].classList.add("attacked")
            if(whitePieces.includes(tempSquare.classList[1])){
                tempSquare.classList.add("open-square")

            }
        }
        
        //en passant left
        if(parseInt(square.dataset.idy)-1>-1&&parseInt(square.dataset.idy)-1<8
        &&parseInt(square.dataset.idx)-1-1>-1&&parseInt(square.dataset.idx)-1-1<8){
            tempSquare = squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1-1)]
            if(tempSquare.classList.contains("white-en-passant-pawn")){
                //console.log("made to here")
                squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1-1)].classList.add("open-square")
                squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1-1)].classList.add("black-en-passant-square")
            }
        }
        //en passant right
        if(parseInt(square.dataset.idy)-1>-1&&parseInt(square.dataset.idy)-1<8
        &&parseInt(square.dataset.idx)-1+1>-1&&parseInt(square.dataset.idx)-1+1<8){
            tempSquare = squares[(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+1)]
            if(tempSquare.classList.contains("white-en-passant-pawn")){
                //console.log("made to here")
                squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1+1)].classList.add("open-square")
                squares[(8*(parseInt(square.dataset.idy)-1+1)+parseInt(square.dataset.idx)-1+1)].classList.add("black-en-passant-square")

            }
        }
    }

}


    

//given a square, highlight all open squares that the pawn could move to

function knightMovement(color,square){
    x=(parseInt(square.dataset.idx)-1+2)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")
    }
    x=(parseInt(square.dataset.idx)-1+2)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-2)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-2)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1+2)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1-2)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1+2)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1-2)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }

    // document.querySelectorAll(".open-square").forEach(square=>{
    //     square.classList.add("attacked")
    // })
}

function whiteKnight(square){
    notChecking = false
    if (square.target!=undefined){
        notChecking = true
        clearPrevious()
        removeWhiteSelections()
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    }
    

    console.log("calling whiteKnight")
    x=(parseInt(square.dataset.idx)-1+2)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1+2)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-2)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-2)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1+2)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1-2)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1+2)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1-2)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    
    blackPiecesToCapture()
    whiteLastSelectedPiece =  square.classList[1]
    whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
    if(notChecking){
        doesMoveHangWhiteKing(false)
    }
    addWhiteEventListenersToOpenSquares()
    addWhiteEventListenersToCapturables()
    highlightCurrentSquare(square)

}

function whiteBishop(square){
    notChecking = false
    if (square.target!=undefined){
        notChecking = true
        clearPrevious()
        removeWhiteSelections()
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    }
    console.log("calling whiteBishop")
    var i = 1
    var j = 1
    var flag=true
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1-j)
        ////console.log(whitePieces.includes(squares[(8*(y))+x]))
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1-j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    blackPiecesToCapture()
    whiteLastSelectedPiece =  square.classList[1]
    whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
    if(notChecking)
        doesMoveHangWhiteKing(false)
    addWhiteEventListenersToOpenSquares()
    addWhiteEventListenersToCapturables()
    highlightCurrentSquare(square)

}

function bishopMovement(color,square){
    let oppositeColor = setOppositeColor(color)
    var i = 1
    var j = 1
    var flag=true
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1-j)
        ////console.log(vars[color+"Pieces"].includes(squares[(8*(y))+x]))
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                console.log(typeof attackedPiece)
                if(typeof attackedPiece == "undefined"){
                    var attackedPiece = squares[(8*(y))+x]
                    squares[(8*(y))+x].classList.add("open-square")
                    squares[(8*(y))+x].classList.add("attacked")
                    console.log("attackedPiece:",attackedPiece)
                }
                else if(squares[(8*(y))+x].classList[1]==oppositeColor+"-king"){
                    console.log("adding pinned to",attackedPiece)
                    attackedPiece.classList.add("pinned")
                    flag = false
                }
                else{
                    flag = false
                }
            }
            else{
                squares[(8*(y))+x].classList.add("open-square")
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1-j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    // document.querySelectorAll(".open-square").forEach(square=>{
    //     square.classList.add("attacked")
    // })
}

function whiteRook(square){
    notChecking = false

    if (square.target!=undefined){
        clearPrevious()
        removeWhiteSelections()
        notChecking = true
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    }
    console.log("calling whiteRook")
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1+i)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1-i)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    blackPiecesToCapture()
    whiteLastSelectedPiece =  square.classList[1]
    whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
    if(notChecking)
        doesMoveHangWhiteKing(false)
    addWhiteEventListenersToOpenSquares()
    addWhiteEventListenersToCapturables()
}

function rookMovement(color,square){
    let oppositeColor = setOppositeColor(color)
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1)
        //if the next square is not one of my pieces, add it as an open square
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            //if the next square is one of my opponents pieces, stop looking in that direction
            
            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                if(typeof attackedPiece != "undefined"){
                    let attackedPiece = squares[(8*(y))+x]
                }
                else{
                    attackedPiece.classList.add("pinned")
                    flag = false
                }
                // flag=false
            }
            //otherwise keep going
        }
        //if the next square is one of my pieces, stop going
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                if(typeof attackedPiece != "undefined"){
                    let attackedPiece = squares[(8*(y))+x]
                }
                else{
                    attackedPiece.classList.add("pinned")
                    flag = false
                }
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1+i)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                if(typeof attackedPiece != "undefined"){
                    let attackedPiece = squares[(8*(y))+x]
                }
                else{
                    attackedPiece.classList.add("pinned")
                    flag = false
                }
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1-i)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                if(typeof attackedPiece != "undefined"){
                    let attackedPiece = squares[(8*(y))+x]
                }
                else{
                    attackedPiece.classList.add("pinned")
                    flag = false
                }
            }
        }
        else{
            flag=false
        }
        i++
    }

    // document.querySelectorAll(".open-square").forEach(square=>{
    //     console.log("adding attacked to:",square)
    //     square.classList.add("attacked")
    // })
}



function whiteKing(square){
    notChecking = false
    if (square.target!=undefined){
        clearPrevious()
        removeWhiteSelections()
        notChecking = true
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    }
    console.log("calling whiteKing")
    highlightCurrentSquare(square)
    x=(parseInt(square.dataset.idx)-1)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
    }
    if(!whiteKingOrRookMoved&&!allPieces.includes(squaresMatrix[7][5].classList[1])&&!allPieces.includes(squaresMatrix[7][6].classList[1])){
        squaresMatrix[7][6].classList.add("open-square")
        squaresMatrix[7][7].classList.add("open-square")
        squaresMatrix[7][7].classList.add("castleable-light")
        //console.log("adding castleable")
    }
    if(!whiteKingOrRookMoved&&!allPieces.includes(squaresMatrix[7][3].classList[1])&&!allPieces.includes(squaresMatrix[7][2].classList[1])&&!allPieces.includes(squaresMatrix[7][1].classList[1])){
        squaresMatrix[7][2].classList.add("open-square")
        squares[56].classList.add("open-square")
        squares[56].classList.add("castleable-dark")
    }
    blackPiecesToCapture()
    whiteLastSelectedPiece =  square.classList[1]
    whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
    if(notChecking)
        doesMoveHangWhiteKing(false)
    addWhiteEventListenersToOpenSquares()
    addWhiteEventListenersToCapturables()
    highlightCurrentSquare(square)

}

function kingMovement(color,square){
    // highlightCurrentSquare(square)
    x=(parseInt(square.dataset.idx)-1)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1+1)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
    x=(parseInt(square.dataset.idx)-1-1)
    y=(parseInt(square.dataset.idy)-1+1)
    if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
        squares[(8*(y))+x].classList.add("open-square")
        squares[(8*(y))+x].classList.add("attacked")

    }
   
    if(color=="white"){
        if(vars[color+"CastleableKS"]&&!allPieces.includes(squaresMatrix[7][5].classList[1])&&!allPieces.includes(squaresMatrix[7][6].classList[1])&&squares[63].classList.contains("white-rook")&&!document.getElementsByClassName("white-king")[0].classList.contains("check")){
        squaresMatrix[7][6].classList.add("open-square")
        squaresMatrix[7][7].classList.add("open-square")
        squaresMatrix[7][7].classList.add("castleable-light")
        //console.log("adding castleable")
    }

        if(vars[color+"CastleableQS"]&&!allPieces.includes(squaresMatrix[7][3].classList[1])&&!allPieces.includes(squaresMatrix[7][2].classList[1])&&!allPieces.includes(squaresMatrix[7][1].classList[1])&&squares[56].classList.contains("white-rook")&&!document.getElementsByClassName("white-king")[0].classList.contains("check")){
            squaresMatrix[7][2].classList.add("open-square")
            squares[56].classList.add("open-square")
            squares[56].classList.add("castleable-dark")
        }
    }
    else{
        if(vars[color+"CastleableKS"]&&!allPieces.includes(squaresMatrix[0][5].classList[1])&&!allPieces.includes(squaresMatrix[0][6].classList[1])&&squares[7].classList.contains("black-rook")&&!document.getElementsByClassName("black-king")[0].classList.contains("check")){
            squaresMatrix[0][6].classList.add("open-square")
            squaresMatrix[0][7].classList.add("open-square")
            squaresMatrix[0][7].classList.add("castleable-dark")
        }
        if(vars[color+"CastleableQS"]&&!allPieces.includes(squaresMatrix[0][3].classList[1])&&!allPieces.includes(squaresMatrix[0][2].classList[1])&&!allPieces.includes(squaresMatrix[0][1].classList[1])&&squares[0].classList.contains("black-rook")&&!document.getElementsByClassName("black-king")[0].classList.contains("check")){
            squaresMatrix[0][2].classList.add("open-square")
            squaresMatrix[0][0].classList.add("open-square")
            squaresMatrix[0][0].classList.add("castleable-light")
        }
    }
    // document.querySelectorAll(".open-square").forEach(square=>{
    //     square.classList.add("attacked")
    // })
}


function whiteQueen(square){
    notChecking = false
    if (square.target!=undefined){
        clearPrevious()
        removeWhiteSelections()
        notChecking = true
        square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    }
    console.log("calling whiteQueen")

    var i = 1
    var j = 1
    var flag=true
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1-j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1-j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1+i)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1-i)
        if(x>-1&&x<8&&y>-1&&y<8&&!whitePieces.includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            if(blackPieces.includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    blackPiecesToCapture()
    whiteLastSelectedPiece =  square.classList[1]
    whiteLastSelectedLocation = 8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1
    if(notChecking)
        doesMoveHangWhiteKing
    addWhiteEventListenersToOpenSquares()
    addWhiteEventListenersToCapturables()
    highlightCurrentSquare(square)

}

function queenMovement(color,square){
    let oppositeColor = setOppositeColor(color)
    var i = 1
    var j = 1
    var flag=true
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1-j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1-j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    j=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1+j)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
        j++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1+i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1-i)
        y=(parseInt(square.dataset.idy)-1)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1+i)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")
            // console.log("adding attacked to",squares[(8*(y))+x])
            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    flag=true
    i=1
    while(flag){
        x=(parseInt(square.dataset.idx)-1)
        y=(parseInt(square.dataset.idy)-1-i)
        if(x>-1&&x<8&&y>-1&&y<8&&!vars[color+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
            squares[(8*(y))+x].classList.add("open-square")
            squares[(8*(y))+x].classList.add("attacked")

            if(vars[oppositeColor+"Pieces"].includes(squares[(8*(y))+x].classList[1])){
                flag=false
            }
        }
        else{
            flag=false
        }
        i++
    }
    // document.querySelectorAll(".open-square").forEach(square=>{
    //     square.classList.add("attacked")
    // })
}

function blackPiecesToCapture(){
    // console.log("calling blackPiecesToCapture")
    squares.forEach(square =>{
        // //console.log(square.classList.contains("open-square"))
        if(square.classList.contains("open-square")&&blackPieces.includes(square.classList[1])||
        square.classList[1]=="black-en-passant-pawn"){
        // ||blackPieces.includes(square.classList[2])){
            if(square.classList[0]=="blackSquare"){
                // square.classList.remove("open-square")
                square.classList.add("capturable-dark")
            }
            
            else{
                // square.classList.remove("open-square")
                square.classList.add("capturable-light")
            }
        }
    });
}


function countPieceValuesAttackingWhite(square){
    console.log("calling countPieceValeusAttackingWhite")
    if(square.classList.contains("white-pawn")||square.classList.contains("black-en-passant-square")){
        square.value += 1
    }
    else if(square.classList.contains("black-pawn-en-passant")){
        square.value += 1
    }
    else if(square.classList.contains("white-knight")){
        square.value += 3
    }
    else if(square.classList.contains("white-bishop")){
        square.value += 3
    }
    else if(square.classList.contains("white-rook")){
        square.value += 5
    }
    else if(square.classList.contains("white-queen")){
        square.value += 9
    }
    else if(square.classList.contains("white-king")){
        square.value += 1000
    }
    
}

function countPieceValuesAttackingBlack(square){
    console.log("calling countPieceValuesAttackingBlack")
    if(square.classList.contains("black-pawn")){
        square.value = 1
    }
    else if(square.classList.contains("white-pawn-en-passant")){
        square.value = 1
    }
    else if(square.classList.contains("black-knight")){
        square.value = 3
    }
    else if(square.classList.contains("black-bishop")){
        square.value = 3
    }
    else if(square.classList.contains("black-rook")){
        square.value = 5
    }
    else if(square.classList.contains("black-queen")){
        square.value = 9
    }
    else if(square.classList.contains("black-king")){
        square.value = 1000
    }
}


function whitePiecesToCapture(){
    // console.log("calling whitePiecesToCapture")
    squares.forEach(square =>{
    
        // //console.log(square.classList.contains("open-square"))
        if(square.classList.contains("open-square")&&(whitePieces.includes(square.classList[1])
        ||square.classList[1]=="white-en-passant-pawn")){
            if(square.classList[0]=="blackSquare"){
                // square.classList.remove("open-square")
                square.classList.add("capturable-dark")
            }
            else{
                // square.classList.remove("open-square")
                square.classList.add("capturable-light")
            }
        }
    });
}   

function setOppositeColor(color){
    if(color=="white")
        return "black"
    else
        return "white"
}

function piecesToCapture(color){
    console.log("calling pieces to capture",color)

    // console.log("calling whitePiecesToCapture")
    if(color=="white")
        oppositeColor = "black"
    else
        oppositeColor = "white"
    

    openSquares = document.querySelectorAll(".open-square")
    openSquares.forEach(square =>{
        
        if(vars[oppositeColor+"Pieces"].includes(square.classList[1])){
            console.log(square)
            if(square.classList[0]=="blackSquare"){
                // square.classList.remove("open-square")
                console.log("adding capturable dark")
                square.classList.add("capturable-dark")
            }
            else{
                // square.classList.remove("open-square")
                console.log("adding capturable light")

                square.classList.add("capturable-light")
            }
        }
    })
    // squares.forEach(square =>{
        
    //     // //console.log(square.classList.contains("open-square"))
    //     if(square.classList.contains("open-square")&&(vars[oppositeColor+"Pieces"].includes(square.classList[1])
    //     ||square.classList[1]=="white-en-passant-pawn")){
    //         if(square.classList[0]=="blackSquare"){
    //             // square.classList.remove("open-square")
    //             square.classList.add("capturable-dark")
    //         }
    //         else{
    //             // square.classList.remove("open-square")
    //             square.classList.add("capturable-light")
    //         }
    //     }
    // });
}   

async function blackMoving(){
    let square = squaresMatrix[parseInt(this.dataset.idy-1)][parseInt(this.dataset.idx-1)]
    temp = blackLastSelectedLocation
    // blackMovingEventListeners(square)
    console.log("calling blackMoving")
    selectingPieceBlack=false
        if(square.classList.contains("white-en-passant-pawn")){
            square.classList.remove("white-pawn")
        }
        if(square.classList.contains("capturable-dark")||square.classList.contains("capturable-light")){
            square.classList.remove(square.classList[1])
        }
        
        // //console.log(blackLastSelectedPiece)
        // //console.log(blackLastSelectedLocation)
        // square.classList.add("taken")
        if(blackLastSelectedPiece==="black-king"&&blackLastSelectedLocation===4&&!blackKingOrRookMoved&&(square===squaresMatrix[0][6]||square===squaresMatrix[0][7])){
            //console.log("castleing kingside")
            squaresMatrix[0][6].classList.add("black-king")
            squaresMatrix[0][5].classList.add("black-rook")
            squaresMatrix[0][7].classList.remove("black-rook")
            squaresMatrix[0][4].classList.remove("black-king")
        }
        else if(blackLastSelectedPiece==="black-king"&&blackLastSelectedLocation===4&&!blackKingOrRookMoved&&(square===squaresMatrix[0][2]||square===squaresMatrix[0][0])){
            //console.log("castleing queenside")
            squaresMatrix[0][2].classList.add("black-king")
            squaresMatrix[0][3].classList.add("black-rook")
            squaresMatrix[0][0].classList.remove("black-rook")
            squaresMatrix[0][4].classList.remove("black-king")
        }
        else{
            square.classList.add(blackLastSelectedPiece)
        }
        if(blackLastSelectedPiece==="black-king"||blackLastSelectedPiece==="black-rook"){
            blackKingOrRookMoved = true;
        }
        // squares[blackLastSelectedLocation].classList.remove("taken")
        squares[blackLastSelectedLocation].classList.remove(blackLastSelectedPiece)
        squares.forEach(square =>{
            square.classList.remove("selecting-dark")        
                square.classList.remove("selecting-light")
                square.classList.remove("white-en-passant-pawn")
            if(square.classList.contains("open-square")){
                square.classList.remove("open-square")
                square.classList.remove("capturable-dark")
                square.classList.remove("capturable-light")
                // if(square.classList[1]=="white-pawn"){
                //     square.classList.remove(square.classList[1])
                // }
                // square.classList.remove("white-pawn")
                square.classList.remove("castleable-dark")
                square.classList.remove("castleable-light")
                // if(whitePieces.includes(square.classList[1])){
                //     square.classList.remove(square.classList[1])
                // }
            }
        });
        //pawn promotion
        if(blackLastSelectedPiece==="black-pawn"&&parseInt(square.dataset.idy)===8){
            //console.log("promoting on square "+(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1))
            // square.classList.add("black-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.add("black-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.add("black-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.add("black-bishop")
            // squares[arguments[0]+8].addEventListener(pawnHighlight)
            square.classList.remove("black-pawn")
            blackPawnPromotion(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)
            // await blackPromotionChooser()
            //console.log("done promoting")
            // square.classList.remove("black-queen")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+8].classList.remove("black-knight")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+16].classList.remove("black-rook")
            // squares[8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1+24].classList.remove("black-bishop")
        }

        //en passant candidates
        if(blackLastSelectedPiece==="black-pawn"&&blackLastSelectedLocation+16===(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
            square.classList.add("black-en-passant-pawn")
        }


        //capturing en passant
        if(square.classList.contains("black-en-passant-square")){
            squares[8*(parseInt(square.dataset.idy)-1-1)+parseInt(square.dataset.idx)-1].classList.remove("white-pawn")
            //these 3 lines cause error because of this not being square. dont think they are necessary tho
            // squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("white-en-passant-pawn")
            // squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("capturable-light")
            // squares[8*(parseInt(this.dataset.idy)-1+1)+parseInt(this.dataset.idx)-1].classList.remove("capturable-dark")
            square.classList.remove("black-en-passant-square")
        }
        blackIsPromoting = false
        blackLastSelectedLocation = temp
        blackRemoveLastPieceEventListeners()
        console.log("here")
        if(!blackIsPromoting){
            isWhiteKinginCheck(document.getElementsByClassName("white-king")[0])
            if(document.getElementsByClassName("white-king")[0].classList.contains("check")){
                didWhiteGetMated()
            }
            if(blackLastSelectedPiece=="black-king"){
                squares[blackLastSelectedLocation].classList.remove("check")
            }
            else{
                document.getElementsByClassName("black-king")[0].classList.remove("check")
            }
            switchTurn()
        }
}










function blackPawnMoveValues(square){
    console.log("calling blackPawnMoveValues")
    if(centerSquare.includes(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
        square.value+=1
    }
    if((parseInt(square.dataset.idy)-1==4)){
        square.value+=.25
    }
    else if((parseInt(square.dataset.idy)-1==5)){
        square.value+=.5
    }
    else if((parseInt(square.dataset.idy)-1==6)){
        square.value+=2
    }
    else if((parseInt(square.dataset.idy)-1==7)){
        square.value+=8
    }
}

function blackKnightMoveValues(square){
    console.log("calling blackKnightMoveValues")
    if(edges.includes(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
        square.value-=1
    }
}

function blackBishopMoveValues(square){
    console.log("calling blackBishopMoveValues")
    if(fianchettoSquares.includes(8*(parseInt(square.dataset.idy)-1)+parseInt(square.dataset.idx)-1)){
        square.value+=1
    }
}











function whiteWins(){
    console.log("calling whiteWins")
    let winner=document.querySelector(".winner")
    winner.innerHTML="White Won!"
    // currentPlayer.innerHTML=""
    // var x = document.querySelector('.player')
    // x.innerHTML=''
    var span = document.querySelector(".currentPlayer");
    //console.log(span.childNodes[1])
    span.removeChild(span.childNodes[1]);  
}

function blackWins(){
    console.log("calling blackWins")
    //console.log("blackWins")
    let winner=document.querySelector(".winner")
    winner.innerHTML="Black Won!"
    // currentPlayer.innerHTML=""
    // var x = document.querySelector('.player')
    // x.innerHTML=''
    var span = document.querySelector(".currentPlayer");
    //console.log(span.childNodes[1])
    span.removeChild(span.childNodes[1]);  
}

function colorWins(color){
    console.log("calling colorWins",color)
    let winner=document.querySelector(".winner")
    winner.innerHTML=color +" won!"
    // currentPlayer.innerHTML=""
    // var x = document.querySelector('.player')
    // x.innerHTML=''
    var span = document.querySelector(".currentPlayer");
    //console.log(span.childNodes[1])
    span.removeChild(span.childNodes[1]);  
}

//     function selecting(){

//         let square = squares[8*(parseInt(this.dataset.idy)-1)+parseInt(this.dataset.idx)-1]
//         if(square.classList.contains("open-square")){
//             square.classList.remove("open-square")
//             square.classList.add(whiteLastSelectedPiece)
//             squares[whiteLastSelectedLocation].classList.remove(whiteLastSelectedPiece)
//             squares.forEach(square =>{
//                 if(square.classList.contains("open-square")){
//                     square.classList.remove("open-square")
//                 }
//             });
//         }
//         else{
        
//         }
//         Array.from(squares).forEach(square=>{ 
//             square.addEventListener("click",whiteClickBox)
//             square.removeEventListener("click",selecting)
//         })
//         // let open_squares = document.querySelectorAll("open-square")
//         // //console.log(open_squares)
// //         [].forEach.call(document.querySelectorAll("open-square"),function(e){
// //   e.parentNode.removeChild(e);
// // });
//         // var open_squares = document.getElementsByClassName("open-square")
    
//         }





    ////console.log(squares)
    // //console.log(parseInt(this.dataset.idx),parseInt(this.dataset.idy))
    // //console.log(square)
    // if(!square)){ 
    //     if(currentPlayer==='white'){ 
    //         currentPlayer='black' 
    //         player.innerHTML=currentPlayer
    //         this.className="player-one taken" 
    //        // checkWon() 
    //      }else if(currentPlayer==='black'){ 
    //         currentPlayer='white'
    //         player.innerHTML=currentPlayer 
    //         this.className="player-two taken" 
    //         //checkWon() 
    //     } 
    // }else{
    //     // alert("You cannot build on an empty space or on a space that has been built on")
    // } 

    //the checkWon function
function checkWon(){
    console.log("calling checkWon")
    let squares =document.querySelectorAll(".board div")
    for (let y=0;y<winningArray.length;y++){
        let square =winningArray[y]
        if(square.every(q=>squares[q].classList.contains("player-one"))){
            setTimeout(() =>alert("player one(red) wins "), 200)
            setTimeout(() =>restart.style.display="flex", 500)
        }else if(square.every(q=>squares[q].classList.contains("player-two"))){
            setTimeout(() =>alert("player two(yellow) wins"), 200)
            setTimeout(() =>restart.style.display="flex", 500)
        }
    }
}

function reset(){
    console.log("calling reset")
    board.innerHTML="" 
    loadDOM() 
    restart.style.display="none" 
}

   

</script>

